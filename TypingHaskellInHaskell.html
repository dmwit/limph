<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" CONTENT="TtH 2.73">
                                                                                             

 
<title> Typing Haskell in Haskell</title>
 
<h1 align="center">Typing Haskell in Haskell<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a> </h1>

<h3 align=center>MARK P. JONES<br>
        Pacific Software Research Center <br>Department of Computer Science and Engineering <br>Oregon Graduate Institute of Science and Technology <br>20000 NW Walker Road, Beaverton, OR 97006, USA<br><tt>mpj@cse.ogi.edu</tt><br><br>Version of November 23, 2000.
 </h3> 


<p>

<h2> Abstract</h2>
Haskell benefits from a sophisticated type system, but implementors,
programmers, and researchers suffer because it has no formal
description.  To remedy this shortcoming, we present a Haskell program
that implements a Haskell typechecker, thus providing a mathematically
rigorous specification in a notation that is familiar to Haskell users.
We expect this program to fill a serious gap in current descriptions of
Haskell, both as a starting point for discussions about existing features
of the type system, and as a platform from which to explore new proposals.

<p>


<p>
       <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Introduction</h2>
Haskell<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
benefits from one of the most sophisticated type systems of
any widely used programming language.  Unfortunately, it also suffers
because there is no formal specification of what the type system should
be.  As a result:

<ul>

<li> It is hard for Haskell implementors to be sure that their
      systems accept the same programs as
      other implementations.  The informal specification in the
      Haskell report [<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>]leaves too much room for
      confusion and misinterpretation.  This leads to genuine
      discrepancies between implementations, as subscribers to
      the Haskell mailing list will have seen.

<p>

<li> It is hard for Haskell programmers to understand the
      details of the type system and to appreciate why some
      programs are accepted when others are not.  Formal
      presentations of most aspects of the type system are
      available, but they often abstract on specific features that
      are Haskell-like, but not Haskell-exact, and do not describe
      the complete type system.  Moreover, these papers tend to use
      disparate and unfamiliar technical notation and concepts that
      may be difficult for some Haskell programmers to understand.

<p>

<li> It is hard for Haskell researchers to explore new type
      system extensions, or even to study usability issues that
      arise with the present type system such as the search
      for better type error diagnostics.  Work in these areas
      requires a clear understanding of the type system and,
      ideally, a platform on which to build and experiment
      with prototype implementations.  The existing Haskell
      implementations are not suitable for this (and were not
      intended to be): the nuts and bolts of a type system are
      easily obscured by the use of clever data structures
      and optimizations, or by the need to integrate smoothly
      with other parts of an implementation.

<p>
</ul>This paper presents a formal description of the Haskell type
system using the notation of Haskell itself as a specification
language.  Indeed, the source code for this paper is itself
an executable Haskell program that is passed through a custom
preprocessor and then through L<sup>A</sup>T<sub>E</sub>X&nbsp;to obtain the typeset
version.  The type checker is available in source form on the
Internet at <tt>http://www.cse.ogi.edu/&#126;mpj/thih/</tt>.  We hope
that this will serve as a resource for the Haskell community,
and that it will be a significant
step in addressing the problems described previously.

<p>
One audience whose needs may not be particularly well met by this
paper are researchers in programming language type systems who do
not have experience of Haskell.  (Of course, we encourage
anyone in that position to learn more about Haskell!)  Indeed,
we do not follow the traditional route in such settings where
the type system might first be presented in its purest form,
and then related to a more concrete type inference algorithm by
soundness and completeness theorems.  Here, we deal only with
type inference.  It does not even make sense to ask
if our algorithm computes `principal' types: such a question
requires a comparison between two different presentations of
a type system, and we only have one.  Nevertheless, we believe
that our specification could be recast
in a standard, type-theoretic manner and used to develop
a presentation of Haskell typing in a more traditional style.

<p>
The code presented here can be executed with any Haskell
system, but our primary goals have been clarity and simplicity,
and the resulting code is not intended to be an efficient
implementation of type inference.  Indeed, in some places,
our choice of representation may lead to significant overheads
and duplicated computation.  It would be interesting to try to
derive a more efficient, but provably correct implementation
from the specification given here.  We have not attempted to
do this because we expect that it would obscure the key ideas
that we want to emphasize.  It therefore remains as a topic for
future work, and as a test to assess the applicability of program
transformation and synthesis to modestly sized Haskell programs.

<p>
Another goal of this paper is to give as complete a description
of the Haskell type system as possible, while also aiming for
conciseness.  For this to be possible, we have assumed that
certain transformations and checks will have been made prior to
typechecking, and hence that we can work with a much simpler
abstract syntax than the full source-level syntax of Haskell
would suggest.  As we argue informally at various points in the
paper, we do not believe that there would be any significant
difficulty in extending our system to deal with the missing
constructs.  All of the fundamental components, including
the thorniest aspects of Haskell typing, are addressed in
the framework that we present here.  Our specification does
not attempt to deal with all of the issues that would occur
in the implementation of a type checker in a full Haskell
implementation.  We do not tackle the problems of interfacing
a typechecker with compiler front ends (to track source code
locations in error diagnostics, for example) or back ends
(to describe the implementation of overloading, for example),
nor do we attempt to formalize any of the extensions that
are implemented in current Haskell systems.  This is one
of things that makes our specification relatively concise
(429 lines of Haskell code).  By comparison, the core parts
of the Hugs typechecker take some 90+ pages of C code.

<p>
Some examples are included in the paper to illustrate the
datatypes and representations that are used.  However, for
reasons of space, the definitions of some constants that
represent entities in the standard prelude, as well as the
machinery that we use in testing to display the results of type
inference, are included only in the electronic distribution,
and not in the typeset version of the paper.  Apart from those
details, this paper gives the full source code.

<p>
We expect the program described here to evolve in at least three
different ways.

<ul>

<li> Formal specifications are not immune to error, and so
      it is possible that changes will be required to correct bugs
      in the code presented here.  On the other hand, by writing
      our specification as a program that can be typechecked
      and executed with existing Haskell implementations,
      we have a powerful facility for detecting simple bugs
      automatically and for testing to expose deeper problems.

<p>

<li> As it stands, this paper just provides one more
      interpretation of the Haskell type system.  We believe
      that it is consistent with the official specification,
      but because the latter is given only informally,
      we cannot prove the correctness of our program in a
      rigorous manner.  Instead, we hope that our code,
      perhaps with some modifications, will eventually serve
      as a precise definition of the Haskell type system,
      capturing a consensus within the Haskell community.
      There is some evidence that this goal is already within
      reach: no discrepancies or technical changes have been
      discovered or reported in more than a year since the first
      version of this program was released.

<p>

<li> Many extensions of the Haskell type system have been
      proposed, and several of these have already been
      implemented in one or more of the available Haskell
      systems.  Some of the better known examples of this
      include multiple-parameter type classes, existential
      types, rank-2 polymorphism, and extensible records.  We
      would like to obtain formal descriptions for as many of
      these proposals as possible by extending the core
      specification presented here.

<p>
</ul>It will come as no surprise to learn that some knowledge
of Haskell will be required to read this paper.
That said, we have tried to keep the definitions and code as
clear and simple as possible, and although we have made some use
of Haskell overloading and do-notation, we have generally avoided
using the more esoteric features of Haskell.  In addition,
some experience with the basics of Hindley-Milner style type
inference [<a href="#Hindley" name="CITEHindley"> Hindley, 1969</a>,<a href="#Milner" name="CITEMilner"> Milner, 1978</a>,<a href="#DamasMilner" name="CITEDamasMilner"> Damas &amp; Milner, 1982</a>]will be needed to
understand the algorithms presented here.  Although we have aimed
to keep our presentation as simple as possible, some aspects
of the problems that we are trying to address have inherent
complexity or technical depth that cannot be side-stepped.
In short, this paper will probably not be useful as a tutorial
introduction to Hindley-Milner style type inference!

<p>
       <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Preliminaries</h2>
For simplicity, we present the code for our typechecker as
a single Haskell module.  The program uses only a handful
of standard prelude functions, like <tt>map</tt>, <tt>concat</tt>,
<tt>all</tt>, <tt>any</tt>, <tt>mapM</tt>, etc., and a few operations
from the <tt>List</tt> and <tt>Monad</tt> libraries:

<p>

<pre>
  module TypingHaskellInHaskell where
  import List(nub, (\\), intersect, union, partition)
  import Monad(msum)
</pre>

<p>
For the most part, our choice of variable names follows the
notational conventions set out in Figure&nbsp;<a href="#fig-notation">1</a>.

<p>
<a name="tth_fIg1">
</a> 

<center>
<p>

<table>
<tr><td>Description      </td><td>Symbol                 </td><td>Type </td></tr>
<tr><td>kind             </td><td><tt>k, ...</tt>            </td><td><tt>Kind</tt> </td></tr>
<tr><td>type constructor </td><td><tt>tc, ...</tt>           </td><td><tt>Tycon</tt> </td></tr>
<tr><td>type variable    </td><td><tt>v, ...</tt>            </td><td><tt>Tyvar</tt> </td></tr>
<tr><td>- `fixed'       </td><td><tt>f, ...</tt>            </td><td></td></tr>
<tr><td>- `generic'     </td><td><tt>g, ...</tt>            </td><td></td></tr>
<tr><td>type             </td><td><tt>t, ...</tt>            </td><td><tt>Type</tt> </td></tr>
<tr><td>class            </td><td><tt>c, ...</tt>            </td><td><tt>Class</tt> </td></tr>
<tr><td>instance         </td><td><tt>it, ...</tt>           </td><td><tt>Inst</tt> </td></tr>
<tr><td>predicate        </td><td><tt>p, q, ...</tt>         </td><td><tt>Pred</tt> </td></tr>
<tr><td>- `deferred'    </td><td><tt>d, ...</tt>            </td><td></td></tr>
<tr><td>- `retained'    </td><td><tt>r, ...</tt>            </td><td></td></tr>
<tr><td>qualified type   </td><td><tt>qt, ...</tt>           </td><td><tt>QualType</tt> </td></tr>
<tr><td>class environment</td><td><tt>ce, ...</tt>           </td><td><tt>ClassEnv</tt> </td></tr>
<tr><td>scheme           </td><td><tt>sc, ...</tt>           </td><td><tt>Scheme</tt> </td></tr>
<tr><td>substitution     </td><td><tt>s, ...</tt>            </td><td><tt>Subst</tt> </td></tr>
<tr><td>unifier          </td><td><tt>u, ...</tt>            </td><td><tt>Subst</tt> </td></tr>
<tr><td>assumption       </td><td><tt>a, ...</tt>            </td><td><tt>Assump</tt> </td></tr>
<tr><td>identifier       </td><td><tt>i, ...</tt>            </td><td><tt>Id</tt> </td></tr>
<tr><td>literal          </td><td><tt>l, ...</tt>            </td><td><tt>Literal</tt> </td></tr>
<tr><td>pattern          </td><td><tt>pat, ...</tt>          </td><td><tt>Pat</tt> </td></tr>
<tr><td>expression       </td><td><tt>e, f, ...</tt>         </td><td><tt>Expr</tt> </td></tr>
<tr><td>alternative      </td><td><tt>alt, ...</tt>          </td><td><tt>Alt</tt> </td></tr>
<tr><td>binding group    </td><td><tt>bg, ...</tt>           </td><td><tt>BindGroup</tt> </td></tr></table>

</center>

<center>Figure 1: Notational Conventions</center>
<a name="fig-notation">
</a>

<p>

<p>
A trailing <tt>s</tt> on a variable name usually indicates a list.
Numeric suffices or primes are used as further decoration
where necessary.  For example, we use <tt>k</tt> or <tt>k'</tt> for a
kind, and <tt>ks</tt> or <tt>ks'</tt> for a list of kinds.  The types
and terms appearing in the table are described more fully in
later sections.  To distinguish the code for the typechecker
from program fragments that are used to discuss its behavior,
we typeset the former in an <tt>italic</tt> font, and the latter
in a <tt>typewriter</tt> font.

<p>
Throughout this paper, we implement identifiers as strings, and assume
that there is a simple way to generate identifiers from integers using
the <tt>enumId</tt> function:

<p>

<pre>
  type Id  = String
 
  enumId  :: Int -&#62; Id
  enumId n = "v" ++ show n
</pre>

<p>
The <tt>enumId</tt> function will be used in the definition of the
<tt>newTVar</tt> operator in Section&nbsp;<a href="#sec-atimonad">10</a> to describe the
allocation of fresh type variables during type inference.  With the
simple implementation shown here, we assume that variable names
beginning with ``<tt>v</tt>'' do not appear in input programs.

<p>
       <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Kinds</h2><a name="sec-kinds">
</a>
To ensure that they are valid, Haskell type constructors
are classified into different <em>kinds</em>: the kind <tt>*</tt>
(pronounced `star') represents the set of all simple (i.e.,
nullary) type expressions, like <tt>Int</tt> and <tt>Char -&#62; Bool</tt>;
kinds of the form <tt>k1 -&#62; k2</tt> represent type constructors
that take an argument type of kind <tt>k1</tt> to a result type of
kind <tt>k2</tt>.  For example, the standard list, <tt>Maybe</tt> and
<tt>IO</tt> constructors all have kind <tt>* -&#62; *</tt>.  Here,
we will represent kinds as values of the following datatype:

<p>

<pre>
  data Kind  = Star | Kfun Kind Kind
               deriving Eq
</pre>

<p>
Kinds play essentially the same role for type constructors
as types do for values, but the kind system is clearly
very primitive.  There are a number of extensions
that would make interesting topics for future research,
including polymorphic kinds, subkinding, and record/product
kinds.  A simple extension of the kind system-adding a new
<tt>row</tt> kind-has already proved to be useful for the Trex
implementation of extensible records in Hugs [<a href="#GasterJones" name="CITEGasterJones"> Gaster &amp; Jones, 1996</a>,<a href="#HugsManual" name="CITEHugsManual"> Jones &amp; Peterson, 1999</a>].

<p>
       <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Types</h2><a name="sec-types">
</a>
The next step is to define a representation for types.
Stripping away syntactic sugar,
Haskell type expressions are either type variables or constants
(each of which has an associated kind), or applications of
one type to another: applying a type of kind <tt>k1 -&#62; k2</tt> to
a type of kind <tt>k1</tt> produces a type of kind <tt>k2</tt>:

<p>

<pre>
  data Type  = TVar Tyvar | TCon Tycon | TAp  Type Type | TGen Int
               deriving Eq
 
  data Tyvar = Tyvar Id Kind
               deriving Eq
</pre>

<p>

<pre>
  data Tycon = Tycon Id Kind
               deriving Eq
</pre>

<p>
This definition also includes types of the form <tt>TGen n</tt>, which
represent `generic' or quantified type variables.  The only place
where <tt>TGen</tt> values are used is in the representation of type
schemes, which will be described in Section&nbsp;<a href="#sec-schemes">8</a>.

<p>
The following examples show how standard primitive datatypes
are represented as type constants:

<p>

<pre>
  tUnit    = TCon (Tycon "()" Star)
  tChar    = TCon (Tycon "Char" Star)
  tInt     = TCon (Tycon "Int" Star)
  tInteger = TCon (Tycon "Integer" Star)
  tFloat   = TCon (Tycon "Float" Star)
  tDouble  = TCon (Tycon "Double" Star)
 
  tList    = TCon (Tycon "[]" (Kfun Star Star))
  tArrow   = TCon (Tycon "(-&#62;)" (Kfun Star (Kfun Star Star)))
  tTuple2  = TCon (Tycon "(,)" (Kfun Star (Kfun Star Star)))
</pre>

<p>
A full Haskell compiler or interpreter might store additional
information with each type constant-such as the the list of
constructor functions for an algebraic datatype-but such
details are not needed during typechecking.

<p>
More complex types are built up from constants and variables
using the <tt>TAp</tt> constructor.  For example, the representation
for the type <tt>Int -&#62; [a]</tt> is as follows:

<p>

<pre>
  TAp (TAp tArrow tInt) (TAp tList (TVar (Tyvar "a" Star)))
</pre>

<p>
We do not provide a representation for type synonyms,
assuming instead that they have been fully expanded before
typechecking.  For example, the <tt>String</tt> type-a synonym
for <tt>[Char]</tt>-is represented as:

<p>

<pre>
  tString    :: Type
  tString     = list tChar
</pre>

<p>
It is always possible for an implementation to expand synonyms in this
way because Haskell prevents the use of a synonym without
its full complement of arguments.  Moreover, the process is
guaranteed to terminate because recursive synonym definitions
are prohibited.  In practice, however, implementations are
likely to expand synonyms more lazily: in some cases, type
error diagnostics may be easier to understand if they display
synonyms rather than expansions.

<p>
We end this section with the definition of a few helper functions.
The first three provide simple ways to construct function, list,
and pair types, respectively:

<p>

<pre>
  infixr      4 `fn`
  fn         :: Type -&#62; Type -&#62; Type
  a `fn` b    = TAp (TAp tArrow a) b
 
  list       :: Type -&#62; Type
  list t      = TAp tList t
</pre>

<p>

<pre>
  pair       :: Type -&#62; Type -&#62; Type
  pair a b    = TAp (TAp tTuple2 a) b
</pre>

<p>
We also define an overloaded function, <tt>kind</tt>, that can
be used to determine the kind of a type variable, type constant,
or type expression:

<p>

<pre>
  class HasKind t where
    kind :: t -&#62; Kind
  instance HasKind Tyvar where
    kind (Tyvar v k) = k
  instance HasKind Tycon where
    kind (Tycon v k) = k
  instance HasKind Type where
    kind (TCon tc) = kind tc
    kind (TVar u)  = kind u
    kind (TAp t _) = case (kind t) of
                       (Kfun _ k) -&#62; k
</pre>

<p>
Most of the cases here are straightforward.  Notice, however,
that we can calculate the kind of an application <tt>(TAp t t')</tt>
using only the kind of its first argument <tt>t</tt>:  Assuming that
the type is well-formed, <tt>t</tt> must have a kind <tt>k'-&#62;k</tt>,
where <tt>k'</tt> is the kind of <tt>t'</tt> and <tt>k</tt> is the kind of
the whole application.  This shows that we need only traverse
the leftmost spine of a type expression to calculate its kind.

<p>
       <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Substitutions</h2><a name="sec-substs">
</a>
Substitutions-finite functions, mapping type variables to
types-play a major role in type inference.
In this paper, we represent substitutions using association
lists:

<p>

<pre>
  type Subst  = [(Tyvar, Type)]
</pre>

<p>
To ensure that we work only with well-formed type expressions,
we will be careful to construct only <em>kind-preserving</em>
substitutions in which variables are mapped only to types
of the same kind.  
The simplest substitution is the null substitution, represented
by the empty list, which is obviously kind-preserving:

<p>

<pre>
  nullSubst  :: Subst
  nullSubst   = []
</pre>

<p>
Almost as simple are the substitutions <tt>(u +-&#62; t)</tt><a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a> that map a single variable
<tt>u</tt> to a type <tt>t</tt> of the same kind:

<p>

<pre>
  (+-&#62;)      :: Tyvar -&#62; Type -&#62; Subst
  u +-&#62; t     = [(u, t)]
</pre>

<p>
This is kind-preserving if, and only if, <tt>kind u = kind t</tt>.

<p>
Substitutions can be applied to types-and, in fact, to any
other value with type components-in a natural way.  This
suggests that we overload the operation to <tt>apply</tt> a
substitution so that it can work on different types of object:

<p>

<pre>
  class Types t where
    apply :: Subst -&#62; t -&#62; t
    tv    :: t -&#62; [Tyvar]
</pre>

<p>
In each case, the purpose of applying a substitution is
the same: To replace every occurrence of a type variable in
the domain of the substitution with the corresponding type.
We also include a function <tt>tv</tt> that returns the set of
type variables (i.e., <tt>Tyvar</tt>s) appearing in its argument,
listed in order of first occurrence (from left to right),
with no duplicates.  The definitions of these operations for
<tt>Type</tt> are as follows:

<p>

<pre>
  instance Types Type where
    apply s (TVar u)  = case lookup u s of
                         Just t  -&#62; t
                         Nothing -&#62; TVar u
    apply s (TAp l r) = TAp (apply s l) (apply s r)
    apply s t         = t
 
    tv (TVar u)  = [u]
    tv (TAp l r) = tv l `union` tv r
    tv t         = []
</pre>

<p>
It is straightforward (and useful!) to extend these operations
to work on lists:

<p>

<pre>
  instance Types a =&#62; Types [a] where
    apply s = map (apply s)
    tv      = nub . concat . map tv
</pre>

<p>
The <tt>apply</tt> function can be used to build more complex
substitutions.  For example, composition of substitutions,
satisfying <tt>apply (s1 @@ s2) = apply s1 . apply s2</tt>,
can be defined using:

<p>

<pre>
  infixr 4 @@
  (@@)       :: Subst -&#62; Subst -&#62; Subst
  s1 @@ s2    = [ (u, apply s1 t) | (u,t) &lt;- s2 ] ++ s1
</pre>

<p>
We can also form a `parallel' composition <tt>s1++s2</tt> of
two substitutions <tt>s1</tt> and <tt>s2</tt>, but the result is
left-biased because bindings in <tt>s1</tt> take precedence
over any bindings for the same variables in <tt>s2</tt>.  For a
more symmetric version of this operation, we use a <tt>merge</tt>
function, which checks that the two substitutions agree at
every variable in the domain of both and hence guarantees
that <tt>apply (s1++s2) = apply (s2++s1)</tt>.  Clearly, this is a
partial function, which we reflect by arranging for <tt>merge</tt>
to return its result in a monad, using the standard <tt>fail</tt>
function to provide a string diagnostic in cases where the
function is undefined.

<p>

<pre>
  merge      :: Monad m =&#62; Subst -&#62; Subst -&#62; m Subst
  merge s1 s2 = if agree then return (s1++s2) else fail "merge fails"
   where agree = all (\v -&#62; apply s1 (TVar v) == apply s2 (TVar v))
                     (map fst s1 `intersect` map fst s2)
</pre>

<p>
It is easy to check that both <tt>(@@)</tt> and <tt>merge</tt> produce
kind-preserving results from kind-preserving arguments.  In the
next section, we will see how the first of these composition
operators is used to describe unification, while the second is
used in the formulation of a matching operation.

<p>
       <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Unification and Matching</h2><a name="sec-unify">
</a>
The goal of unification is to find a substitution that makes
two types equal-for example, to ensure that the domain type
of a function matches up with the type of an argument value.
However, it is also important for unification to find as
`small' a substitution as possible because that will
lead to most general types.  More formally, a substitution
<tt>s</tt> is a <em>unifier</em> of two types <tt>t1</tt> and <tt>t2</tt> if
<tt>apply s t1 = apply s t2</tt>.  A <em>most general unifier</em>,
or <em>mgu</em>, of two such types is a unifier <tt>u</tt> with
the property that any other unifier <tt>s</tt> can be written as
<tt>s'@@u</tt>, for some substitution <tt>s'</tt>.

<p>
The syntax of Haskell types has been chosen to ensure
that, if two types have any unifying substitutions, then they
have a most general unifier, which can be calculated by
a simple variant of Robinson's algorithm [<a href="#Robinson" name="CITERobinson"> Robinson, 1965</a>].
One of the reasons for this is that there are no
non-trivial equalities on types.  Extending the type system
with higher-order features (such as lambda expressions on
types), or with other mechanisms that allow reductions or
rewriting in the type language, could make unification
undecidable, non-unitary (meaning that there may not be most
general unifiers), or both.  This, for example, is why Haskell
does not allow type synonyms to be partially applied (and
interpreted as some restricted kind of lambda expression).

<p>
The calculation of most general unifiers is implemented by
a pair of functions:

<p>

<pre>
  mgu     :: Monad m =&#62; Type -&#62; Type -&#62; m Subst
  varBind :: Monad m =&#62; Tyvar -&#62; Type -&#62; m Subst
</pre>

<p>
These functions return results in a monad, capturing the fact
that unification is a partial function.  The main algorithm
is described by <tt>mgu</tt>, using the structure of its arguments
to guide the calculation:

<p>

<pre>
  mgu (TAp l r) (TAp l' r') = do s1 &lt;- mgu l l'
                                 s2 &lt;- mgu (apply s1 r) (apply s1 r')
                                 return (s2 @@ s1)
  mgu (TVar u) t        = varBind u t
  mgu t (TVar u)        = varBind u t
  mgu (TCon tc1) (TCon tc2)
             | tc1==tc2 = return nullSubst
  mgu t1 t2             = fail "types do not unify"
</pre>

<p>
The <tt>varBind</tt> function is used for the special case of unifying
a variable <tt>u</tt> with a type <tt>t</tt>.  At first glance, one
might think that we could just use the substitution <tt>(u+-&#62;t)</tt>
for this.  In practice, however, tests are required to ensure that
this is valid, including an `occurs check' (<tt>u `elem` tv t</tt>)
and a test to ensure that the substitution is kind-preserving:

<p>

<pre>
  varBind u t | t == TVar u      = return nullSubst
              | u `elem` tv t    = fail "occurs check fails"
              | kind u /= kind t = fail "kinds do not match"
              | otherwise        = return (u +-&#62; t)
</pre>

<p>
In the following sections, we will also make use of an operation
called <em>matching</em> that is closely related to unification.
Given two types <tt>t1</tt> and <tt>t2</tt>, the goal of matching is to
find a substitution <tt>s</tt> such that <tt>apply s t1 = t2</tt>.  Because
the substitution is applied only to one type, this operation is
often described as <em>one-way</em> matching.  The calculation of
matching substitutions is implemented by a function:

<p>

<pre>
  match :: Monad m =&#62; Type -&#62; Type -&#62; m Subst
</pre>
 
<p>
Matching follows the same pattern as unification, except that
it uses <tt>merge</tt> rather than <tt>@@</tt> to combine substitutions,
and it does not allow binding of variables in <tt>t2</tt>:

<p>

<pre>
  match (TAp l r) (TAp l' r') = do sl &lt;- match l l'
                                   sr &lt;- match r r'
                                   merge sl sr
  match (TVar u)   t | kind u == kind t = return (u +-&#62; t)
  match (TCon tc1) (TCon tc2)
           | tc1==tc2         = return nullSubst
  match t1 t2                 = fail "types do not match"
</pre>

<p>
       <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Type Classes, Predicates and Qualified Types</h2><a name="sec-preds">
</a>
One of the most unusual features of the Haskell type system,
at least in comparison to those of other polymorphically typed
languages like ML, is the support that it provides for <em>type
classes</em>.  Described by Wadler and Blott [<a href="#WadlerBlott" name="CITEWadlerBlott"> Wadler &amp; Blott, 1989</a>]
as a general mechanism that subsumes several ad-hoc forms of
overloading, type classes have found many uses (and, sometimes,
abuses!) in the ten years since they were introduced.  A significant
portion of the code presented in this paper, particularly in this
section, is needed to describe
the handling of type classes in Haskell.  (Of course, type classes
are not the only source of complexity.  The treatment of mixed
implicit and explicit typing, mutually recursive bindings, and
pattern matching-which are often elided in more theoretical
presentations-are also significant contributors, as is the extra
level of detail and precision that is needed in executable code.)

<p>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Basic Definitions</h3><a name="sec-basic-pred">
</a>
A Haskell type class can be thought of as a set of types (of some
particular kind), each of which supports a certain collection of
<em>member functions</em> that are specified as part of the class
declaration.  The types in each class (known as <tt>instances</tt>)
are specified by a collection of instance declarations.  Haskell
types can be <em>qualified</em> by adding a (possibly empty) list of
<em>predicates</em>, or class constraints, to restrict the ways in
which type variables are instantiated<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>:

<p>

<pre>
  data Qual t = [Pred] :=&#62; t
                deriving Eq
</pre>

<p>
In a value of the form <tt>ps :=&#62; t</tt>, we refer to <tt>ps</tt> as
the <em>context</em> and to <tt>t</tt> as the <em>head</em>.  Predicates
themselves consist of a class identifier and a type; a predicate
of the form <tt>IsIn i t</tt> asserts that <tt>t</tt> is a member of the
class named <tt>i</tt>:

<p>

<pre>
  data Pred   = IsIn Id Type
                deriving Eq
</pre>

<p>
For example, using the <tt>Qual</tt> and <tt>Pred</tt> datatypes, the
type <tt>(Num a) =&#62; a -&#62; Int</tt> can be represented by:

<p>

<pre>
  [IsIn "Num" (TVar (Tyvar "a" Star))] :=&#62; (TVar (Tyvar "a" Star) `fn` tInt)
</pre>

<p>
It would be easy to extend the <tt>Pred</tt> datatype to allow
other forms of predicate, as is done with Trex records in Hugs
[<a href="#HugsManual" name="CITEHugsManual"> Jones &amp; Peterson, 1999</a>].  Another frequently requested extension is
to allow classes to accept multiple parameters, which would
require a list of <tt>Type</tt>s rather than the single <tt>Type</tt>
in the definition above.

<p>
The extension of <tt>Types</tt> to the <tt>Qual</tt> and <tt>Pred</tt>
datatypes is straightforward:

<p>

<pre>
  instance Types t =&#62; Types (Qual t) where
    apply s (ps :=&#62; t) = apply s ps :=&#62; apply s t
    tv (ps :=&#62; t)      = tv ps `union` tv t
 
  instance Types Pred where
    apply s (IsIn i t) = IsIn i (apply s t)
    tv (IsIn i t)      = tv t
</pre>

<p>
The tasks of calculating most general unifiers and matching
substitutions on types also extend naturally to predicates:

<p>

<pre>
  mguPred, matchPred :: Pred -&#62; Pred -&#62; Maybe Subst
  mguPred             = lift mgu
  matchPred           = lift match
 
  lift m (IsIn i t) (IsIn i' t')
           | i == i'   = m t t'
           | otherwise = fail "classes differ"
</pre>

<p>
We will represent each class by a pair of lists, one containing
the name of each superclass, and another containing an entry for
each instance declaration:

<p>

<pre>
  type Class    = ([Id], [Inst])
  type Inst     = Qual Pred
</pre>

<p>
For example, a simplified version of the standard Haskell class
<tt>Ord</tt> might be described by the following value of type <tt>Class</tt>:

<p>

<pre>
  (["Eq"], [[] :=&#62; IsIn "Ord" tUnit,
            [] :=&#62; IsIn "Ord" tChar,
            [] :=&#62; IsIn "Ord" tInt,
            [IsIn "Ord" (TVar (Tyvar "a" Star)),
             IsIn "Ord" (TVar (Tyvar "b" Star))]
               :=&#62; IsIn "Ord" (pair (TVar (Tyvar "a" Star))
                                    (TVar (Tyvar "b" Star)))])
</pre>

<p>
This structure captures the fact that <tt>Eq</tt> is a superclass
of <tt>Ord</tt> (the only one in fact), and lists four instance
declarations for the unit, character, integer, and pair types
(if <tt>a</tt> and <tt>b</tt> are in <tt>Ord</tt>, then <tt>(a,b)</tt> is also
in <tt>Ord</tt>).  Of course, this is only a fraction of the list of
<tt>Ord</tt> instances that are defined in the full Haskell prelude.
Only the details that are needed for type inference are included
in these representations.  A full Haskell implementation would
need to store additional information for each declaration, such
as the list of member functions for each class and details of
their implementations in each particular instance.

<p>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Class Environments</h3><a name="sec-classenv">
</a>
The information provided by the class and instance declarations
in a given program can be captured by a class environment of type:

<p>

<pre>
  data ClassEnv = ClassEnv { classes  :: Id -&#62; Maybe Class,
                             defaults :: [Type] }
</pre>

<p>
The <tt>classes</tt> component in a <tt>ClassEnv</tt> value is a
partial function that maps identifiers to <tt>Class</tt> values
(or to <tt>Nothing</tt> if there is no class corresponding to the
specified identifier).  We define helper functions <tt>super</tt>
and <tt>insts</tt> to extract the list of superclass identifiers,
and the list of instances, respectively, for a class name <tt>i</tt>
in a class environment <tt>ce</tt>:

<p>

<pre>
  super     :: ClassEnv -&#62; Id -&#62; [Id]
  super ce i = case classes ce i of Just (is, its) -&#62; is
 
  insts     :: ClassEnv -&#62; Id -&#62; [Inst]
  insts ce i = case classes ce i of Just (is, its) -&#62; its
</pre>

<p>
These functions are intended to be used only in cases where it
is known that the class <tt>i</tt> is defined in the environment
<tt>ce</tt>.  In some cases, this condition might be guaranteed by
static analysis prior to type checking.  Alternatively, we can
resort to a dynamic check by testing <tt>defined (classes ce i)</tt>
before applying either function.  The function <tt>defined</tt> used
here is defined as follows<a href="#tthFtNtAAF" name="tthFrefAAF"><sup>5</sup></a>:

<p>

<pre>
  defined :: Maybe a -&#62; Bool
  defined (Just x) = True
  defined Nothing  = False
</pre>

<p>
We will also define a helper function, <tt>modify</tt>, to describe
how a class environment can be updated to reflect a new binding
of a <tt>Class</tt> value to a given identifier:

<p>

<pre>
  modify       :: ClassEnv -&#62; Id -&#62; Class -&#62; ClassEnv
  modify ce i c = ce{classes = \j -&#62; if i==j then Just c
                                             else classes ce j}
</pre>

<p>
The <tt>defaults</tt> component of a <tt>ClassEnv</tt> value is used to provide
a list of types for defaulting, as described in Section&nbsp;<a href="#sec-default">11.5.1</a>.
Haskell allows programmers to specify a
value for this list using a <tt>default</tt> declaration; if no explicit
declaration is given, then a <tt>default (Integer,Double)</tt> declaration
is assumed.  It is easy to describe this using the <tt>ClassEnv</tt> type.
For example, <tt>cedefaults=[tInt]</tt> is the result of modifying a class
environment <tt>ce</tt> to reflect the presence of a <tt>default (Int)</tt>
declaration.  Further discussion of defaulting is deferred to
Section&nbsp;<a href="#sec-default">11.5.1</a>.

<p>
In the remainder of this section, we will show how to build an
appropriate class environment for a given program, starting from an
(almost) empty class environment, and extending it as necessary
to reflect the effect of each class or instance declaration in
the program.  The initial class environment is defined as follows:

<p>

<pre>
  initialEnv :: ClassEnv
  initialEnv  = ClassEnv { classes  = \i -&#62; fail "class not defined",
                           defaults = [tInteger, tDouble] }
</pre>

<p>
As we process each class or instance declaration in a program,
we transform the initial class environment to add entries,
either for a new class, or for a new instance, respectively.
In either case, there is a possibility that the new declaration
might be incompatible with the previous declarations, attempting,
for example, to redefine an existing class or instance.  For this
reason, we will describe transformations of a class environment
as functions of the <tt>EnvTransformer</tt> type, using a <tt>Maybe</tt>
type to allow for the possibility of errors:

<p>

<pre>
  type EnvTransformer = ClassEnv -&#62; Maybe ClassEnv
</pre>

<p>
The sequencing of multiple transformers can be described by a
(forward) composition operator <tt>(&lt;:&#62;)</tt>:

<p>

<pre>
  infixr 5 &lt;:&#62;
  (&lt;:&#62;)       :: EnvTransformer -&#62; EnvTransformer -&#62; EnvTransformer
  (f &lt;:&#62; g) ce = do ce' &lt;- f ce
                    g ce'
</pre>

<p>
Some readers will recognize this as a special case of the more
general Kleisli composition operator; without the type declaration,
the definition given here would work for any monad and for
any element types, not just for <tt>Maybe</tt> and <tt>ClassEnv</tt>.

<p>
To add a new class to an environment, we must check that
there is not already a class with the same name, and that all of
the named superclasses are already defined.  This is a simple way
of enforcing Haskell's restriction that the superclass hierarchy
be acyclic.  Of course, in practice, it will be necessary to
topologically sort the set of class declarations in a program to
determine a suitable ordering; any cycles in the hierarchy will
typically be detected at this stage.

<p>

<pre>
  addClass                              :: Id -&#62; [Id] -&#62; EnvTransformer
  addClass i is ce
   | defined (classes ce i)              = fail "class already defined"
   | any (not . defined . classes ce) is = fail "superclass not defined"
   | otherwise                           = return (modify ce i (is, []))
</pre>

<p>
For example, we can describe the effect of the class declarations
in the Haskell prelude using the following transformer:

<p>

<pre>
  addPreludeClasses :: EnvTransformer
  addPreludeClasses  = addCoreClasses &lt;:&#62; addNumClasses
</pre>

<p>
This definition breaks down the set of standard Haskell classes
into two separate pieces.  The core classes are described as
follows:

<p>

<pre>
  addCoreClasses ::   EnvTransformer
  addCoreClasses  =   addClass "Eq" []
                  &lt;:&#62; addClass "Ord" ["Eq"]
                  &lt;:&#62; addClass "Show" []
                  &lt;:&#62; addClass "Read" []
                  &lt;:&#62; addClass "Bounded" []
                  &lt;:&#62; addClass "Enum" []
                  &lt;:&#62; addClass "Functor" []
                  &lt;:&#62; addClass "Monad" []
</pre>

<p>
The hierarchy of numeric classes is captured separately in the
following definition:

<p>

<pre>
  addNumClasses  ::   EnvTransformer
  addNumClasses   =   addClass "Num" ["Eq", "Show"]
                  &lt;:&#62; addClass "Real" ["Num", "Ord"]
                  &lt;:&#62; addClass "Fractional" ["Num"]
                  &lt;:&#62; addClass "Integral" ["Real", "Enum"]
                  &lt;:&#62; addClass "RealFrac" ["Real", "Fractional"]
                  &lt;:&#62; addClass "Floating" ["Fractional"]
                  &lt;:&#62; addClass "RealFloat" ["RealFrac", "Floating"]
</pre>

<p>
To add a new instance to a class, we must check that the
class to which the instance applies is defined, and that the new
instance does not overlap with any previously declared instance:

<p>

<pre>
  addInst                        :: [Pred] -&#62; Pred -&#62; EnvTransformer
  addInst ps p@(IsIn i _) ce
   | not (defined (classes ce i)) = fail "no class for instance"
   | any (overlap p) qs           = fail "overlapping instance"
   | otherwise                    = return (modify ce i c)
     where its = insts ce i
           qs  = [ q | (_ :=&#62; q) &lt;- its ]
           c   = (super ce i, (ps:=&#62;p) : its)
</pre>

<p>
Two instances for a class are said to <em>overlap</em> if there is
some predicate that is a substitution instance of the heads of
both instance declarations.  It is easy to test for overlapping
predicates using the functions that we have defined previously:

<p>

<pre>
  overlap       :: Pred -&#62; Pred -&#62; Bool
  overlap p q    = defined (mguPred p q)
</pre>

<p>
This test covers simple cases where a program provides two
instance declarations for the same type (for example, two
declarations for <tt>Eq Int</tt>), but it also covers cases
where more interesting overlaps occur (for example, between
the predicates <tt>Eq [Int]</tt> and <tt>Eq [a]</tt>, or between
predicates <tt>Eq (a,Bool)</tt> and <tt>Eq (Int,b)</tt>).  In each
case, the existence of an overlap indicates the possibility of a
semantic ambiguity, with two applicable instance declarations,
and no clear reason to prefer one over the other.  This is why
Haskell treats such overlaps as an error.  Extensions to Haskell
to support overlapping instances in certain special cases have
been considered elsewhere; they appear to have interesting
applications, but also have some potentially troublesome impact
on program semantics [<a href="#multi" name="CITEmulti"> Peyton Jones <em>et&nbsp;al.</em> , 1997</a>].  We will not consider such
issues further in this paper.

<p>
To illustrate how the <tt>addInst</tt> function might be used,
the following definition shows how the standard prelude class
environment can be extended to include the four instances for
<tt>Ord</tt> from the example in Section&nbsp;<a href="#sec-basic-pred">7.1</a>:

<p>

<pre>
  exampleInsts ::  EnvTransformer
  exampleInsts =   addPreludeClasses
               &lt;:&#62; addInst [] (IsIn "Ord" tUnit)
               &lt;:&#62; addInst [] (IsIn "Ord" tChar)
               &lt;:&#62; addInst [] (IsIn "Ord" tInt)
               &lt;:&#62; addInst [IsIn "Ord" (TVar (Tyvar "a" Star)),
                            IsIn "Ord" (TVar (Tyvar "b" Star))]
                           (IsIn "Ord" (pair (TVar (Tyvar "a" Star))
                                             (TVar (Tyvar "b" Star))))
</pre>

<p>
The Haskell report imposes some further restrictions on class and
instance declarations that are not enforced by the definitions of
<tt>addClass</tt> and <tt>addInst</tt>.  For example, the superclasses
of a class should have the same kind as the class itself; the
parameters of any predicates in an instance context should be
type variables, each of which should appear in the head of the
instance; and the type appearing in the head of an instance should
consist of a type constructor applied to a sequence of distinct
type variable arguments.  Because these conditions have no direct
impact on type checking, and because they are straightforward
but tedious to verify, we have chosen not to include tests for
them here, and instead assume that they have been checked during
static analysis prior to type checking.

<p>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Entailment</h3><a name="sec-entail">
</a>
In this section, we describe how class environments can be
used to answer questions about which types are instances of
particular classes.  More generally, we consider the treatment
of <em>entailment</em>: given a predicate <tt>p</tt> and a list of
predicates <tt>ps</tt>, our goal is to determine whether <tt>p</tt> will
hold whenever all of the predicates in <tt>ps</tt> are satisfied.
In the special case where <tt>p = IsIn i t</tt> and <tt>ps = []</tt>,
this amounts to determining whether <tt>t</tt> is an instance of the
class <tt>i</tt>.  In the theory of qualified types [<a href="#Quality" name="CITEQuality"> Jones, 1992</a>],
assertions like this are captured using judgements of the form
<tt>ps ||- p</tt>; we use a different notation here-the <tt>entail</tt>
function that is defined at the end of this section-to make
the dependence on a class environment explicit.

<p>
As a first step, we can ask how information about superclasses
and instances can be used independently to help reason about
entailments.  For example, if a type is an instance of a class
<tt>i</tt>, then it must also be an instance of any superclasses
of <tt>i</tt>.  Hence, using only superclass information, we can be
sure that, if a given predicate <tt>p</tt> holds, then so too must
all of the predicates in the list <tt>bySuper p</tt>:

<p>

<pre>
  bySuper :: ClassEnv -&#62; Pred -&#62; [Pred]
  bySuper ce p@(IsIn i t)
   = p : concat [ bySuper ce (IsIn i' t) | i' &lt;- super ce i ]
</pre>

<p>
The list <tt>bySuper ce p</tt> may contain duplicates, but it will
always be finite because of the restriction that the superclass
hierarchy is acyclic.

<p>
Next we consider how information about instances can be used.
Of course, for a given predicate <tt>p = IsIn i t</tt>, we can find all
the directly relevant instances in a class environment <tt>ce</tt>
by looking in <tt>insts ce i</tt>.  As we have seen, individual
instance declarations are mapped into clauses of the form
<tt>ps :=&#62; h</tt>.  The head predicate <tt>h</tt> describes the general
form of instances that can be constructed from this declaration,
and we can use <tt>matchPred</tt> to determine whether this instance is
applicable to the given predicate <tt>p</tt>.  If it is applicable,
then matching will return a substitution <tt>u</tt>, and the remaining
subgoals are the elements of <tt>map (apply u) ps</tt>.  The following
function uses these ideas to determine the list of subgoals for
a given predicate:

<p>

<pre>
  byInst                   :: ClassEnv -&#62; Pred -&#62; Maybe [Pred]
  byInst ce p@(IsIn i t)    = msum [ tryInst it | it &lt;- insts ce i ]
   where tryInst (ps :=&#62; h) = do u &lt;- matchPred h p
                                 Just (map (apply u) ps)
</pre>

<p>
The <tt>msum</tt> function used here comes from the standard
<tt>Monad</tt> library, and returns the first defined element in a list
of <tt>Maybe</tt> values; if there are no defined elements in
the list, then it returns <tt>Nothing</tt>.  Because Haskell
prevents overlapping instances, there is at most one applicable
instance for any given <tt>p</tt>, and we can be sure that the first
defined element will actually be the <em>only</em>  defined element
in this list.

<p>
The <tt>bySuper</tt> and <tt>byInst</tt> functions can be used in
combination to define a general entailment operator, <tt>entail</tt>.
Given a particular class environment <tt>ce</tt>, the intention here
is that <tt>entail ce ps p</tt> will be <tt>True</tt> if, and only if,
the predicate <tt>p</tt> will hold whenever all of the predicates in
<tt>ps</tt> are satisfied:

<p>

<pre>
  entail        :: ClassEnv -&#62; [Pred] -&#62; Pred -&#62; Bool
  entail ce ps p = any (p `elem`) (map (bySuper ce) ps) ||
                   case byInst ce p of
                     Nothing -&#62; False
                     Just qs -&#62; all (entail ce ps) qs
</pre>

<p>
The first step here is to determine whether <tt>p</tt> can be deduced
from <tt>ps</tt> using only superclasses.  If that fails, we look
for a matching instance and generate a list of predicates <tt>qs</tt>
as a new goal, each of which must, in turn, follow from <tt>ps</tt>.

<p>
Conditions specified in the Haskell report-namely that the class
hierarchy is acyclic and that the types in any instance declaration
are strictly smaller than those in the head-translate into
conditions on the values for the <tt>ClassEnv</tt> that can be passed
in as <tt>ce</tt>, and these are enough to guarantee that tests for
entailment will terminate.  Completeness of the algorithm is also
important: will <tt>entail ce ps p</tt> always return <tt>True</tt> whenever
there is a way to prove <tt>p</tt> from <tt>ps</tt>?  In fact our algorithm
does not cover all possible cases: it does not test to see if <tt>p</tt>
is a superclass of some other predicate <tt>q</tt> for which
<tt>entail ce ps q</tt> is <tt>True</tt>.  Extending the algorithm to test
for this would be very difficult because there is no obvious way to
choose a particular <tt>q</tt>, and, in general, there will be infinitely many
potential candidates to consider.  Fortunately, a technical condition in
the Haskell report
[<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>,Condition 1 on Page 47]
reassures us
that this is not necessary: if <tt>p</tt> can be obtained as an immediate
superclass of some predicate <tt>q</tt> that was built using an instance
declaration in an entailment <tt>entail ce ps q</tt>, then <tt>ps</tt> must
already be strong enough to deduce <tt>p</tt>.  Thus, although we have not
formally proved these properties, we believe that our algorithm is sound,
complete, and guaranteed to terminate.

<p>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Context Reduction</h3><a name="sec-ctxtred">
</a>
Class environments also play an important role in an aspect of the
Haskell type system that is known as <em>context reduction</em>.  The
basic goal of context reduction is to reduce a list of predicates
to an equivalent but, in some sense, simpler list.  The Haskell
report [<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>]provides only informal hints about this
aspect of the Haskell typing, where both pragmatics and theory
have important parts to play.  We believe therefore that this
is one of the areas where a more formal specification will be
particularly valuable.

<p>
One way to simplify a list of predicates is to simplify the type
components of individual predicates in the list.  For example, given
the instance declarations in the Haskell standard prelude, we could
replace any occurrences of predicates like <tt>Eq [a]</tt>, <tt>Eq (a,a)</tt>,
or <tt>Eq ([a],Int)</tt> with <tt>Eq a</tt>.  This is valid because, for any
choice of <tt>a</tt>, each one of these predicates holds if, and only if,
<tt>Eq a</tt> holds.  Notice that, in some cases, an attempt to simplify
type components-for example, by replacing <tt>Eq (a, b)</tt> with
<tt>(Eq a, Eq b)</tt>-may increase the number of predicates in the list.
The extent to which simplifications like this are used in a system of
qualified types has an impact on the implementation and performance of
overloading in practical systems [<a href="#Quality" name="CITEQuality"> Jones, 1992</a>,Chapter 7].
In Haskell, however, the decisions are made for us by a syntactic
restriction that forces us to simplify predicates until we obtain
types in a kind of `head-normal form'.  This terminology is motivated
by similarities with the concept of <em>head-normal forms</em> in
<font face="symbol">l</font
>-calculus.  More precisely, the syntax of Haskell requires
class arguments to be of the form <tt>v t1 ... tn</tt>, where <tt>v</tt> is a
type variable, and <tt>t1</tt>,...,<tt>tn</tt> are types (and n <font face="symbol"></font
> 0).
The following function allows us to determine whether a given predicate
meets these restrictions:

<p>

<pre>
  inHnf       :: Pred -&#62; Bool
  inHnf (IsIn c t) = hnf t
   where hnf (TVar v)  = True
         hnf (TCon tc) = False
         hnf (TAp t _) = hnf t
</pre>

<p>
Predicates that do not fit this pattern must be broken down using
<tt>byInst</tt>.  In some cases, this will result in predicates being
eliminated altogether.  In others, where <tt>byInst</tt> fails, it will
indicate that a predicate is unsatisfiable, and will trigger an
error diagnostic.  This process is captured in the following
definition:

<p>

<pre>
  toHnfs      :: Monad m =&#62; ClassEnv -&#62; [Pred] -&#62; m [Pred]
  toHnfs ce ps = do pss &lt;- mapM (toHnf ce) ps
                    return (concat pss)
 
  toHnf                 :: Monad m =&#62; ClassEnv -&#62; Pred -&#62; m [Pred]
  toHnf ce p | inHnf p   = return [p]
             | otherwise = case byInst ce p of
                             Nothing -&#62; fail "context reduction"
                             Just ps -&#62; toHnfs ce ps
</pre>

<p>
Another way to simplify a list of predicates is to reduce the number of
elements that it contains.  There are several ways that this might
be achieved: by removing duplicates (e.g., reducing <tt>(Eq a, Eq a)</tt>
to <tt>Eq a</tt>); by eliminating predicates that are already known to
hold (e.g., removing any occurrences of <tt>Num Int</tt>);
or by using superclass information (e.g., reducing <tt>(Eq a, Ord a)</tt> to
<tt>Ord a</tt>).  In each case, the reduced list of predicates,
is equivalent to the initial list, meaning that all the predicates in
the first will be satisfied if, and only if, all of the predicates in
the second are satisfied.  The simplification algorithm that we will
use here is based on the observation that a predicate <tt>p</tt> in a
list of predicates <tt>(p:ps)</tt> can be eliminated if <tt>p</tt> is entailed
by <tt>ps</tt>.  As a special case, this will eliminate duplicated
predicates: if <tt>p</tt> is repeated in <tt>ps</tt>, then it will also
be entailed by <tt>ps</tt>.  These ideas are used in the following
definition of the <tt>simplify</tt> function, which loops through each
predicate in the list and uses an accumulating parameter to build up
the final result.  Each time we encounter a predicate that is entailed
by the others, we remove it from the list.

<p>

<pre>
  simplify   :: ClassEnv -&#62; [Pred] -&#62; [Pred]
  simplify ce = loop []
   where loop rs []                            = rs
         loop rs (p:ps) | entail ce (rs++ps) p = loop rs ps
                        | otherwise            = loop (p:rs) ps
</pre>

<p>
Now we can describe the particular form of context reduction used
in Haskell as a combination of <tt>toHnfs</tt> and <tt>simplify</tt>.
Specifically, we use <tt>toHnfs</tt> to reduce the list of predicates
to head-normal form, and then simplify the result: 

<p>

<pre>
  reduce      :: Monad m =&#62; ClassEnv -&#62; [Pred] -&#62; m [Pred]
  reduce ce ps = do qs &lt;- toHnfs ce ps
                    return (simplify ce qs)
</pre>

<p>
As a technical aside, we note that there is some redundancy in the
definition of <tt>reduce</tt>.  The <tt>simplify</tt> function is defined in
terms of <tt>entail</tt>, which makes use of the information provided by
both superclass and instance declarations.  The predicates in <tt>qs</tt>,
however, are guaranteed to be in head-normal form, and hence will not
match instance declarations that satisfy the syntactic restrictions
of Haskell.  It follows that we could make do with a version of
<tt>simplify</tt> that used only the following function in determining
(superclass) entailments:

<p>

<pre>
  scEntail        :: ClassEnv -&#62; [Pred] -&#62; Pred -&#62; Bool
  scEntail ce ps p = any (p `elem`) (map (bySuper ce) ps)
</pre>

<p>
       <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Type Schemes</h2><a name="sec-schemes">
</a>
Type schemes are used to describe polymorphic types, and are
represented using a list of kinds and a qualified type:

<p>

<pre>
  data Scheme = Forall [Kind] (Qual Type)
                deriving Eq
</pre>

<p>
There is no direct equivalent of <tt>Forall</tt> in the syntax of
Haskell.  Instead, implicit quantifiers are inserted as necessary
to bind free type variables.

<p>
In a type scheme <tt>Forall ks qt</tt>, each type of the form
<tt>TGen n</tt> that appears in the qualified type <tt>qt</tt> represents
a generic, or universally quantified type variable whose kind
is given by <tt>ks!!n</tt>.  This is the only place where we will
allow <tt>TGen</tt> values to appear in a type.  We had originally
hoped that this restriction could be captured statically by a
careful choice of the representation for types and type schemes.
Unfortunately, we have not yet found a satisfactory way to enforce
this, and, after considering several alternatives, we
have settled for the representation shown here because it
allows for simple implementations of equality and substitution.
For example, the implementation of <tt>apply</tt> on <tt>Type</tt> values
ignores <tt>TGen</tt> values, so we can be sure that there will be no
variable capture problems in the following definition:

<p>

<pre>
  instance Types Scheme where
    apply s (Forall ks qt) = Forall ks (apply s qt)
    tv (Forall ks qt)      = tv qt
</pre>

<p>
Type schemes are constructed by quantifying a qualified
type <tt>qt</tt> with respect to a list of type variables <tt>vs</tt>:

<p>

<pre>
  quantify      :: [Tyvar] -&#62; Qual Type -&#62; Scheme
  quantify vs qt = Forall ks (apply s qt)
   where vs' = [ v | v &lt;- tv qt, v `elem` vs ]
         ks  = map kind vs'
         s   = zip vs' (map TGen [0..])
</pre>

<p>
Note that the order of the kinds in <tt>ks</tt> is determined by
the order in which the variables <tt>v</tt> appear in <tt>tv qt</tt>,
and not by the order in which they appear in <tt>vs</tt>.  So,
for example, the leftmost quantified variable in a type scheme
will always be represented by <tt>TGen 0</tt>.  By insisting that
type schemes are constructed in this way, we obtain a unique
canonical form for <tt>Scheme</tt> values.  This is important
because it means that we can test whether two type schemes are
the same-for example, to determine whether an inferred type
agrees with a declared type-using Haskell's derived equality,
and without having to implement more complex tests for
<font face="symbol">a</font
>-equivalence.

<p>
In practice, we sometimes need to convert a <tt>Type</tt> into
a <tt>Scheme</tt> without adding any qualifying predicates or
quantified variables.  For this special case, we can use the
following function instead of <tt>quantify</tt>:

<p>

<pre>
  toScheme      :: Type -&#62; Scheme
  toScheme t     = Forall [] ([] :=&#62; t)
</pre>

<p>
To complete our description of type schemes, we need to be able
to instantiate the quantified variables in <tt>Scheme</tt> values.
In fact, for the purposes of type inference, we only need the
special case that instantiates a type scheme with fresh type
variables.  We therefore defer further description of
instantiation to Section&nbsp;<a href="#sec-atimonad">10</a> where the mechanisms
for generating fresh type variables are introduced.

<p>
       <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Assumptions</h2>
Assumptions about the type of a variable are represented by
values of the <tt>Assump</tt> datatype, each of which pairs a
variable name with a type scheme:

<p>

<pre>
  data Assump = Id :&#62;: Scheme
</pre>

<p>
Once again, we can extend the <tt>Types</tt> class to allow the
application of a substitution to an assumption:

<p>

<pre>
  instance Types Assump where
    apply s (i :&#62;: sc) = i :&#62;: (apply s sc)
    tv (i :&#62;: sc)      = tv sc
</pre>

<p>
Thanks to the instance definition for <tt>Types</tt> on lists
(Section&nbsp;<a href="#sec-substs">5</a>), we can also use the <tt>apply</tt> and
<tt>tv</tt> operators on the lists of assumptions that are used to
record the type of each program variable during type inference.
We will also use the following function to find the type of a
particular variable in a given set of assumptions:

<p>

<pre>
  find                 :: Monad m =&#62; Id -&#62; [Assump] -&#62; m Scheme
  find i []             = fail ("unbound identifier: " ++ i)
  find i ((i':&#62;:sc):as) = if i==i' then return sc else find i as
</pre>

<p>
This definition allows for the possibility that the variable <tt>i</tt>
might not appear in <tt>as</tt>.  In practice, occurrences of unbound
variables will probably have been detected in earlier compiler
passes.

<p>
       <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;A Type Inference Monad</h2><a name="sec-atimonad">
</a>
It is now quite standard to use monads as a way to hide certain
aspects of `plumbing' and to draw attention instead to more
important aspects of a program's design [<a href="#Wadler:Essence" name="CITEWadler:Essence"> Wadler, 1992</a>].
The purpose of this section is to define the monad that
will be used in the description of the main type inference
algorithm in Section&nbsp;<a href="#sec-typeinf">11</a>.  Our choice of monad is
motivated by the needs of maintaining a `current substitution'
and of generating fresh type variables during typechecking.
In a more realistic implementation, we might also want to add
error reporting facilities, but in this paper the crude but
simple <tt>fail</tt> function from the Haskell prelude is all that
we require.  It follows that we need a simple state monad with
only a substitution and an integer (from which we can generate
new type variables) as its state:

<p>

<pre>
  newtype TI a = TI (Subst -&#62; Int -&#62; (Subst, Int, a))
 
  instance Monad TI where
    return x   = TI (\s n -&#62; (s,n,x))
    TI f &#62;&#62;= g = TI (\s n -&#62; case f s n of
                              (s',m,x) -&#62; let TI gx = g x
                                          in  gx s' m)
 
  runTI       :: TI a -&#62; a
  runTI (TI f) = x where (s,n,x) = f nullSubst 0
</pre>

<p>
The <tt>getSubst</tt> operation returns the current substitution,
while <tt>unify</tt> extends it with a most general unifier of its arguments:

<p>

<pre>
  getSubst   :: TI Subst
  getSubst    = TI (\s n -&#62; (s,n,s))
 
  unify      :: Type -&#62; Type -&#62; TI ()
  unify t1 t2 = do s &lt;- getSubst
                   u &lt;- mgu (apply s t1) (apply s t2)
                   extSubst u
</pre>

<p>
For clarity, we define the operation that extends the
substitution as a separate function, even though it is used
only here in the definition of <tt>unify</tt>:

<p>

<pre>
  extSubst   :: Subst -&#62; TI ()
  extSubst s' = TI (\s n -&#62; (s'@@s, n, ()))
</pre>

<p>
Overall, the decision to hide the current substitution in the
<tt>TI</tt> monad makes the presentation of type inference much
clearer.  In particular, it avoids heavy use of <tt>apply</tt>
every time an extension is (or might have been) computed.

<p>
There is only one primitive that deals with the integer portion
of the state, using it in combination with <tt>enumId</tt> to
generate a new type variable of a specified kind:

<p>

<pre>
  newTVar    :: Kind -&#62; TI Type
  newTVar k   = TI (\s n -&#62; let v = Tyvar (enumId n) k
                            in  (s, n+1, TVar v))
</pre>

<p>
One place where <tt>newTVar</tt> is useful is
in instantiating a type scheme with new type variables of
appropriate kinds:

<p>

<pre>
  freshInst               :: Scheme -&#62; TI (Qual Type)
  freshInst (Forall ks qt) = do ts &lt;- mapM newTVar ks
                                return (inst ts qt)
</pre>

<p>
The structure of this definition guarantees that <tt>ts</tt> has
exactly the right number of type variables, and each with the
right kind, to match <tt>ks</tt>.  Hence, if the type scheme is
well-formed, then the qualified type returned
by <tt>freshInst</tt> will not contain any unbound generics of
the form <tt>TGen n</tt>.  The definition relies on an auxiliary
function <tt>inst</tt>, which is a variation of <tt>apply</tt> that
works on generic variables.  In other words, <tt>inst ts t</tt>
replaces each occurrence of a generic variable <tt>TGen n</tt>
in <tt>t</tt> with <tt>ts!!n</tt>.  It is convenient to build up the
definition of <tt>inst</tt> using overloading:

<p>

<pre>
  class Instantiate t where
    inst  :: [Type] -&#62; t -&#62; t
  instance Instantiate Type where
    inst ts (TAp l r) = TAp (inst ts l) (inst ts r)
    inst ts (TGen n)  = ts !! n
    inst ts t         = t
  instance Instantiate a =&#62; Instantiate [a] where
    inst ts = map (inst ts)
  instance Instantiate t =&#62; Instantiate (Qual t) where
    inst ts (ps :=&#62; t) = inst ts ps :=&#62; inst ts t
  instance Instantiate Pred where
    inst ts (IsIn c t) = IsIn c (inst ts t)
</pre>

<p>
       <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Type Inference</h2><a name="sec-typeinf">
</a>

<p>
With this section we have reached the heart of the paper,
detailing our algorithm for type inference.  It is here that
we finally see how the machinery that has been built up in
earlier sections is actually put to use.  We develop the
complete algorithm in stages, working through the abstract
syntax of the input language from the simplest part (literals)
to the most complex (binding groups).  Most of the typing rules
are expressed by functions whose types are simple variants of
the following synonym:

<p>

<pre>
  type Infer e t = ClassEnv -&#62; [Assump] -&#62; e -&#62; TI ([Pred], t)
</pre>

<p>
In more theoretical treatments, it would not be surprising to
see the rules expressed in terms of judgments <font face="symbol">G</font
>;P | A\vdash e:t,
where <font face="symbol">G</font
> is a class environment, P is a set of predicates,
A is a set of assumptions, <tt>e</tt> is an expression, and <tt>t</tt> is a
corresponding type [<a href="#Quality" name="CITEQuality"> Jones, 1992</a>].  Judgments like this can be
thought of as 5-tuples, and the typing rules themselves just
correspond to a 5-place relation.  Exactly the same structure
shows up in types of the form <tt>Infer e t</tt>, except that, by
using functions, we distinguish very clearly between input and
output parameters.

<p>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Literals</h3>
Like other languages, Haskell provides special syntax for
constant values of certain primitive datatypes, including
numerics, characters, and strings.  We will represent these
<em>literal</em> expressions as values of the <tt>Literal</tt> datatype:

<p>

<pre>
  data Literal = LitInt  Integer
               | LitChar Char
               | LitRat  Rational
               | LitStr  String
</pre>

<p>
Type inference for literals is straightforward.  For characters,
we just return <tt>tChar</tt>.  For integers, we return a new type
variable <tt>v</tt> together with a predicate to indicate that
<tt>v</tt> must be an instance of the <tt>Num</tt> class.  The cases for
<tt>String</tt> and floating point literals follow similar patterns:

<p>

<pre>
  tiLit            :: Literal -&#62; TI ([Pred],Type)
  tiLit (LitChar _) = return ([], tChar)
  tiLit (LitInt _)  = do v &lt;- newTVar Star
                         return ([IsIn "Num" v], v)
  tiLit (LitStr _)  = return ([], tString)
  tiLit (LitRat _)  = do v &lt;- newTVar Star
                         return ([IsIn "Fractional" v], v)
</pre>

<p>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Patterns</h3><a name="sec-pat">
</a>
Patterns are used to inspect and deconstruct data values
in lambda abstractions, function and pattern bindings, list
comprehensions, do notation, and case expressions.  We will
represent patterns using values of the <tt>Pat</tt> datatype:

<p>

<pre>
  data Pat        = PVar Id
                  | PWildcard
                  | PAs  Id Pat
                  | PLit Literal
                  | PNpk Id Integer
                  | PCon Assump [Pat]
</pre>

<p>
A <tt>PVar i</tt> pattern matches any value and binds the result
to the variable <tt>i</tt>.
A <tt>PWildcard</tt> pattern, corresponding to an underscore <tt>_</tt>
in Haskell syntax, matches any value, but does not bind any
variables.
A pattern of the form <tt>(PAs i pat)</tt>, known as an
``as-pattern'' and written using the syntax <tt>i@pat</tt> in
Haskell, binds the variable <tt>i</tt> to any value that matches
the pattern <tt>pat</tt>, while also binding any variables that
appear in <tt>pat</tt>.
A <tt>PLit l</tt> pattern matches only the particular value denoted
by the literal <tt>l</tt>.
A pattern <tt>(PNpk i k)</tt> is an <tt>(n+k)</tt> pattern, which
matches any positive integral value <tt>m</tt> that is greater
than or equal to <tt>k</tt>, and binds the variable <tt>i</tt> to the
difference <tt>(m-k)</tt>.
Finally, a pattern of the form <tt>PCon a pats</tt> matches only
values that were built using the constructor function <tt>a</tt> with
a sequence of arguments that matches <tt>pats</tt>.  We use values
<tt>a</tt> of type <tt>Assump</tt> to represent constructor functions;
all that we really need for typechecking is the type, although
the name is useful for debugging.  A full implementation would
store additional details, such as arity, and use this to check
that constructor functions in patterns are always fully applied.

<p>
Most Haskell patterns have a direct representation in <tt>Pat</tt>,
but extensions would be needed to account for patterns using
labeled fields.  This is not difficult, but adds some complexity,
which we prefer to avoid in this presentation.

<p>
Type inference for patterns has two goals:  To calculate a
type for each bound variable, and to determine what type of
values the whole pattern might match.  This leads us to look
for a function:

<p>

<pre>
  tiPat :: Pat -&#62; TI ([Pred], [Assump], Type)
</pre>

<p>
Note that we do not need to pass in a list of assumptions
here; by definition, any occurrence of a variable in a pattern
would hide rather than refer to a variable of the same name
in an enclosing scope.

<p>
For a variable pattern, <tt>PVar i</tt>, we just return a new
assumption, binding <tt>i</tt> to a fresh type variable.

<p>

<pre>
  tiPat (PVar i) = do v &lt;- newTVar Star
                      return ([], [i :&#62;: toScheme v], v)
</pre>

<p>
Haskell does not allow multiple use of any variable in a pattern,
so we can be sure that this is the first and only occurrence
of <tt>i</tt> that we will encounter in the pattern.  Wildcards are
typed in the same way except that we do not need to create a new
assumption:

<p>

<pre>
  tiPat PWildcard   = do v &lt;- newTVar Star
                         return ([], [], v)
</pre>

<p>
To type an as-pattern <tt>PAs i pat</tt>, we calculate a set of
assumptions and a type for the <tt>pat</tt> pattern, and then add
an extra assumption to bind <tt>i</tt>:

<p>

<pre>
  tiPat (PAs i pat) = do (ps, as, t) &lt;- tiPat pat
                         return (ps, (i:&#62;:toScheme t):as, t)
</pre>

<p>
For literal patterns, we use <tt>tiLit</tt>
from the previous section:

<p>

<pre>
  tiPat (PLit l) = do (ps, t) &lt;- tiLit l
                      return (ps, [], t)
</pre>

<p>
The rule for <tt>(n+k)</tt> patterns does not fix a type for the bound
variable, but adds a predicate to constrain the choice to instances
of the <tt>Integral</tt> class:

<p>

<pre>
  tiPat (PNpk i k)  = do t &lt;- newTVar Star
                         return ([IsIn "Integral" t], [i:&#62;:toScheme t], t)
</pre>

<p>
The case for constructed patterns is slightly more complex:

<p>

<pre>
  tiPat (PCon (i:&#62;:sc) pats) = do (ps,as,ts) &lt;- tiPats pats
                                  t'         &lt;- newTVar Star
                                  (qs :=&#62; t) &lt;- freshInst sc
                                  unify t (foldr fn t' ts)
                                  return (ps++qs, as, t')
</pre>

<p>
First we use the <tt>tiPats</tt> function, defined below,
to calculate types <tt>ts</tt> for each subpattern in
<tt>pats</tt> together with corresponding lists of assumptions
in <tt>as</tt> and predicates in <tt>ps</tt>.  Next, we generate
a new type variable <tt>t'</tt> that will be used to capture
the (as yet unknown) type of the
whole pattern.  From this information, we would expect
the constructor function at the head of the pattern to
have type <tt>foldr fn t' ts</tt>.  We can check that this is
possible by instantiating the known type <tt>sc</tt> of the
constructor and unifying.

<p>
The <tt>tiPats</tt> function is a variation of <tt>tiPat</tt> that takes
a list of patterns as input, and returns a list of types (together
with a list of predicates and a list of assumptions) as its result.

<p>

<pre>
  tiPats     :: [Pat] -&#62; TI ([Pred], [Assump], [Type])
  tiPats pats = do psasts &lt;- mapM tiPat pats
                   let ps = concat [ ps' | (ps',_,_) &lt;- psasts ]
                       as = concat [ as' | (_,as',_) &lt;- psasts ]
                       ts = [ t | (_,_,t) &lt;- psasts ]
                   return (ps, as, ts)
</pre>

<p>
We have already seen how <tt>tiPats</tt> was used in the treatment of
<tt>PCon</tt> patterns above.  It is also useful in other situations
where lists of patterns are used, such as on the left hand side of
an equation in a function definition.

<p>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Expressions</h3><a name="sec-expr">
</a>
Next we describe type inference for expressions,
represented by the <tt>Expr</tt> datatype:

<p>

<pre>
  data Expr = Var   Id
            | Lit   Literal
            | Const Assump
            | Ap    Expr Expr
            | Let   BindGroup Expr
</pre>

<p>
The <tt>Var</tt> and <tt>Lit</tt> constructors are used to represent
variables and literals, respectively.  The <tt>Const</tt> constructor
is used to deal with named constants, such as the constructor
or selector functions associated with a particular datatype or
the member functions that are associated with a particular class.
We use values of type <tt>Assump</tt> to supply a name and type scheme,
which is all the information that we need for the purposes of type
inference.  Function application is represented using the <tt>Ap</tt>
constructor, while <tt>Let</tt> is used to represent let expressions.
(Note that the definition of the <tt>BindGroup</tt> type, used here to
represent binding groups, will be delayed to Section&nbsp;<a href="#sec-bindgroup">11.6.3</a>.)
Of course, Haskell has a much richer syntax of expressions-which 
includes <font face="symbol">l</font
>-abstractions, case expressions, conditionals, list
comprehensions, and do-notation-but they all have simple translations
into <tt>Expr</tt> values.  For example, a <font face="symbol">l</font
>-expression like <tt>\x-&#62;e</tt>
can be rewritten using a local definition as <tt>let f x = e in f</tt>, where
<tt>f</tt> is a new variable.

<p>
Type inference for expressions is quite straightforward:

<p>

<pre>
  tiExpr                       :: Infer Expr Type
  tiExpr ce as (Var i)          = do sc         &lt;- find i as
                                     (ps :=&#62; t) &lt;- freshInst sc
                                     return (ps, t)
  tiExpr ce as (Const (i:&#62;:sc)) = do (ps :=&#62; t) &lt;- freshInst sc
                                     return (ps, t)
  tiExpr ce as (Lit l)          = do (ps,t) &lt;- tiLit l
                                     return (ps, t)
  tiExpr ce as (Ap e f)         = do (ps,te) &lt;- tiExpr ce as e
                                     (qs,tf) &lt;- tiExpr ce as f
                                     t       &lt;- newTVar Star
                                     unify (tf `fn` t) te
                                     return (ps++qs, t)
  tiExpr ce as (Let bg e)       = do (ps, as') &lt;- tiBindGroup ce as bg
                                     (qs, t)   &lt;- tiExpr ce (as' ++ as) e
                                     return (ps ++ qs, t)
</pre>

<p>
The final case here, for <tt>Let</tt> expressions, uses the function
<tt>tiBindGroup</tt> presented in Section&nbsp;<a href="#sec-bindgroup">11.6.3</a>, to generate
a list of assumptions <tt>as'</tt> for the variables defined in <tt>bg</tt>.
All of these variables are in scope when we calculate a type <tt>t</tt>
for the body <tt>e</tt>, which also serves as the type of the whole
expression.

<p>
     <h3><a name="tth_sEc11.4">
11.4</a>&nbsp;&nbsp;Alternatives</h3><a name="sec-alt">
</a>
The representation of function bindings in following sections
uses <em>alternatives</em>, represented by values of type <tt>Alt</tt>:

<p>

<pre>
  type Alt = ([Pat], Expr)
</pre>

<p>
An <tt>Alt</tt> specifies the left and right hand sides of a
function definition.  With a more complete syntax for <tt>Expr</tt>,
values of type <tt>Alt</tt> might also be used in the representation
of lambda and case expressions.

<p>
For type inference, we begin by using <tt>tiPats</tt> to infer a type
for each of the patterns, and to build a new list <tt>as'</tt> of
assumptions for any bound variables, as described in Section&nbsp;<a href="#sec-pat">11.2</a>.
Next, we calculate the type of the body in the scope of the bound
variables, and combine this with the types of each pattern to
obtain a single (function) type for the whole <tt>Alt</tt>:

<p>

<pre>
  tiAlt                :: Infer Alt Type
  tiAlt ce as (pats, e) = do (ps, as', ts) &lt;- tiPats pats
                             (qs,t)  &lt;- tiExpr ce (as'++as) e
                             return (ps++qs, foldr fn t ts)
</pre>

<p>
In practice, we will often run the typechecker over a
list of alternatives, <tt>alts</tt>, and check that the returned type
in each case agrees with some known type <tt>t</tt>.  This process
can be packaged up in the following definition:

<p>

<pre>
  tiAlts             :: ClassEnv -&#62; [Assump] -&#62; [Alt] -&#62; Type -&#62; TI [Pred]
  tiAlts ce as alts t = do psts &lt;- mapM (tiAlt ce as) alts
                           mapM (unify t) (map snd psts)
                           return (concat (map fst psts))
</pre>

<p>
Although we do not need it here, the signature for <tt>tiAlts</tt>
would allow an implementation to push the type argument inside
the checking of each <tt>Alt</tt>, interleaving unification with
type inference instead of leaving it to the end.  This is essential
in extensions like the support for rank-2 polymorphism in Hugs
where explicit type information plays a key role.
Even in an unextended Haskell implementation, this could still
help to improve the quality of type error messages.  Of course,
we can still use <tt>tiAlts</tt> to infer a type from scratch.  All
this requires is that we generate and pass in a fresh type
variable <tt>v</tt> in the parameter <tt>t</tt> to <tt>tiAlts</tt>, and then
inspect the value of <tt>v</tt> under the current substitution when
it returns.

<p>
     <h3><a name="tth_sEc11.5">
11.5</a>&nbsp;&nbsp;From Types to Type Schemes</h3>
We have seen how lists of predicates are accumulated during type
inference; now we will describe how those predicates are used to
construct inferred types.  This process is sometimes referred to
as <em>generalization</em> because the goal is always to calculate
the most general types that are possible.  In a standard Hindley-Milner
system, we can usually calculate most general types by quantifying
over all relevant type variables that do not appear in the assumptions.
In this section, we will describe how this process is modified to deal
with the predicates in Haskell types.

<p>
To understand the basic problem, suppose that we have run the type
checker over the body of a function <tt>h</tt> to obtain
a list of predicates <tt>ps</tt> and a type&nbsp;<tt>t</tt>.  At this point, to
obtain the most general result, we could infer a type for <tt>h</tt> by
forming the qualified type <tt>qt = (ps :=&#62; t)</tt> and then quantifying
over any variables in <tt>qt</tt> that do not appear in the assumptions.
While this is permitted by the theory of qualified types, it is
often not the best thing to do in practice.  For example:

<ul>

<li>
<p>
  The list <tt>ps</tt> can often be simplified using the context
  reduction process described in Section&nbsp;<a href="#sec-ctxtred">7.4</a>.
  This will also ensure that the syntactic restrictions of Haskell
  are met, requiring all predicates to be in head-normal form.

<li>
<p>
  Some of the predicates in <tt>ps</tt> may contain only `fixed'
  variables (i.e., variables appearing in the assumptions), so
  including those constraints in the inferred type will not be
  of any use [<a href="#Quality" name="CITEQuality"> Jones, 1992</a>,Section 6.1.4].
  These predicates should be `deferred' to the enclosing bindings.

<li>
<p>
  Some of the predicates in <tt>ps</tt> could result in <em>ambiguity</em>,
  and require defaulting to avoid a type error.  This aspect of Haskell's
  type system will be described shortly in Section&nbsp;<a href="#sec-default">11.5.1</a>.
</ul>
<p>
In this paper we use a function called <tt>split</tt>
to address these issues.  For the situation described previously
where we have inferred a type <tt>t</tt> and a list of predicates <tt>ps</tt>
for a function <tt>h</tt>, we can use <tt>split</tt> to rewrite and break
<tt>ps</tt> into a pair <tt>(ds, rs)</tt> of deferred predicates <tt>ds</tt> and
`retained' predicates <tt>rs</tt>.  The predicates in <tt>rs</tt> will be used
to form an inferred type <tt>(rs :=&#62; t)</tt> for <tt>h</tt>, while the predicates
in <tt>ds</tt> will be passed out as constraints to the enclosing scope.
We use the following definition for <tt>split</tt>:

<p>

<pre>
  split :: Monad m =&#62; ClassEnv -&#62; [Tyvar] -&#62; [Tyvar] -&#62; [Pred]
                        -&#62; m ([Pred], [Pred])
  split ce fs gs ps = do ps' &lt;- reduce ce ps
                         let (ds, rs) = partition (all (`elem` fs) . tv) ps'
                         rs' &lt;- defaultedPreds ce (fs++gs) rs
                         return (ds, rs \\ rs')
</pre>

<p>
In addition to a list of predicates <tt>ps</tt>, the <tt>split</tt> function
is parameterized by two lists of type variables.  The first, <tt>fs</tt>,
specifies the set of `fixed' variables, which are just the variables
appearing free in the assumptions.  The second, <tt>gs</tt>, specifies
the set of variables over which we would like to quantify; for the
example above, it would just be the variables in <tt>(tv t \\ fs)</tt>.
It is possible for <tt>ps</tt> to contain variables that are not in
either <tt>fs</tt> or <tt>gs</tt> (and hence not in the parameter <tt>(fs++gs)</tt>
that is passed to <tt>defaultedPreds</tt>).  In Section&nbsp;<a href="#sec-default">11.5.1</a>
we will see that this is an indication of ambiguity.

<p>
There are three stages in the <tt>split</tt> function, corresponding
directly to the three points listed previously.  The first stage
uses <tt>reduce</tt> to perform context reduction.  The second stage
uses the standard prelude function <tt>partition</tt> to identify
the deferred predicates, <tt>ds</tt>; these are just the predicates
in <tt>ps'</tt> that contain only fixed type variables.  The third
stage determines whether any of the predicates in <tt>rs</tt> should
be eliminated using Haskell's defaulting mechanism, and produces a
list of all such predicates in <tt>rs'</tt>.  Hence the final set of
retained predicates is produced by the expression <tt>rs \\ rs'</tt>
in the last line of the definition.

<p>
      <h4><a name="tth_sEc11.5.1">
11.5.1</a>&nbsp;&nbsp;Ambiguity and Defaults</h4><a name="sec-default">
</a>
In the terminology of Haskell
[<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>,Section 4.3.4],
a type scheme <tt>ps =&#62; t</tt> is <em>ambiguous</em> if
<tt>ps</tt> contains generic variables that do not also appear
in <tt>t</tt>.  This condition is important because theoretical
studies [<a href="#Blott" name="CITEBlott"> Blott, 1991</a>,<a href="#Quality" name="CITEQuality"> Jones, 1992</a>]have shown that, in the general
case, we can only guarantee a well-defined semantics for a
term if its most general type is not ambiguous.  As a result,
expressions with ambiguous types are considered ill-typed in
Haskell and will result in a static error.  The following definition
shows a fairly typical example illustrating how ambiguity problems
can occur:

<pre>
   stringInc x = show (read x + 1)
</pre>
The intention here is that a string representation of a number will
be parsed (using the prelude function <tt>read</tt>), incremented, and
converted back to a string (using the prelude function <tt>show</tt>).
But there is a genuine ambiguity because there is nothing to
specify which type of number is intended, and because different choices
can lead to different semantics.  For example, <tt>stringInc "1.5"</tt>
might produce a result of <tt>"2.5"</tt> if floating point numbers
are used, or a parse error (or perhaps a result of <tt>"2"</tt>)
if integers are used.  This semantic ambiguity is reflected by a
syntactic ambiguity in the inferred type of <tt>stringInc</tt>:

<pre>
   stringInc :: (Read a, Num a) =&#62; String -&#62; String
</pre>
(There is no <tt>Show a</tt> constraint here because <tt>Show</tt> is a
superclass of <tt>Num</tt>.)
A programmer can fix this particular problem quite easily by picking
a particular type for <tt>a</tt>, and by adding an appropriate type
annotation:

<pre>
   stringInc x = show (read x + 1 :: Int)
</pre>
Practical experience suggests that ambiguities like this tend
to occur quite infrequently in real Haskell code.  Moreover,
when ambiguities are detected, the error diagnostics that are
generated can often be useful in guiding programmers to genuine
problems in their code.  However, the designers of Haskell felt
that, in some situations involving numeric types-and particularly
involving overloaded numeric literals-the potential for ambiguity
was significant enough to become quite a burden on programmers.
Haskell's <tt>default</tt> mechanism was therefore introduced as
a pragmatic compromise that is convenient-because it automates
the task of picking types for otherwise ambiguous variables-but
also dangerous-because it involves making choices about the
semantics of a program in ways that are not always directly visible
to programmers.  For this latter reason, the use of defaulting
is restricted so that it will only apply under certain, fairly
restrictive circumstances.

<p>
The remainder of this section explains in more detail how ambiguities
in Haskell programs can be detected and, when appropriate, eliminated
by a suitable choice of defaults.
The first step is to identify any sources of ambiguity.  Suppose,
for example, that we are about to qualify a type with a list of
predicates <tt>ps</tt> and that <tt>vs</tt> lists all known variables,
both fixed and generic.  An ambiguity occurs precisely if there is
a type variable that appears in <tt>ps</tt> but not in <tt>vs</tt> (i.e.,
in <tt>tv ps \\ vs</tt>).  The goal of defaulting is
to bind each ambiguous type variable <tt>v</tt> to a monotype <tt>t</tt>.
The type <tt>t</tt> must be chosen so that all of the predicates in
<tt>ps</tt> that involve <tt>v</tt> will be satisfied once <tt>t</tt> has been
substituted for <tt>v</tt>.  The following function calculates
the list of ambiguous variables and pairs each one with the
list of predicates that must be satisfied by any choice of a default:

<p>

<pre>
  type Ambiguity       = (Tyvar, [Pred])
 
  ambiguities         :: ClassEnv -&#62; [Tyvar] -&#62; [Pred] -&#62; [Ambiguity]
  ambiguities ce vs ps = [ (v, filter (elem v . tv) ps) | v &lt;- tv ps \\ vs ]
</pre>

<p>
Given one of these pairs <tt>(v,qs)</tt>, and as specified by
the Haskell report
[<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>,Section 4.3.4],
defaulting is permitted if, and only if, all of the following
conditions are satisfied:

<ul>

<li> All of the predicates in <tt>qs</tt> are of the form
      <tt>IsIn c (TVar v)</tt> for some class <tt>c</tt>.

<p>

<li> At least one of the classes involved in <tt>qs</tt> is a standard
      numeric class.  The list of these class names is
      provided by a constant:

<p>

<pre>
  numClasses :: [Id]
  numClasses  = ["Num", "Integral", "Floating", "Fractional",
                 "Real", "RealFloat", "RealFrac"]
</pre>

<p>

<li> All of the classes involved in <tt>qs</tt> are standard classes,
      defined either in the standard prelude or standard libraries.
      Again, the list of these class names is
      provided by a constant:

<p>

<pre>
  stdClasses :: [Id]
  stdClasses  = ["Eq", "Ord", "Show", "Read", "Bounded", "Enum", "Ix",
                 "Functor", "Monad", "MonadPlus"] ++ numClasses
</pre>

<p>

<li> That there is at least one type in the list of default types for
      the enclosing module that is an instance of all of the classes
      mentioned in <tt>qs</tt>.  The first such type will be selected as
      the default.  The list of default types can be obtained from
      a class environment by using the <tt>defaults</tt> function that
      was described in Section&nbsp;<a href="#sec-classenv">7.2</a>.

<p>
</ul>These conditions are captured rather more succinctly in the following
definition, which we use to calculate the candidates for resolving
a particular ambiguity:

<p>

<pre>
  candidates           :: ClassEnv -&#62; Ambiguity -&#62; [Type]
  candidates ce (v, qs) = [ t' | let is = [ i | IsIn i t &lt;- qs ]
                                     ts = [ t | IsIn i t &lt;- qs ],
                                 all ((TVar v)==) ts,
                                 any (`elem` numClasses) is,
                                 all (`elem` stdClasses) is,
                                 t' &lt;- defaults ce,
                                 all (entail ce []) [ IsIn i t' | i &lt;- is ] ]
</pre>

<p>
If <tt>candidates</tt> returns an empty list for a given ambiguity,
then defaulting cannot be applied to the corresponding variable,
and the ambiguity cannot be avoided.  On the other hand, if
the result is a non-empty list <tt>ts</tt>, then we will be able to
substitute <tt>head ts</tt> for <tt>v</tt> and remove the predicates in
<tt>qs</tt> from <tt>ps</tt>.  The calculations for the defaulting
substitution, and for the list of predicates that it eliminates
follow very similar patterns, which we capture by defining them
in terms of a single, higher-order function:

<p>

<pre>
  withDefaults :: Monad m =&#62; ([Ambiguity] -&#62; [Type] -&#62; a)
                    -&#62; ClassEnv -&#62; [Tyvar] -&#62; [Pred] -&#62; m a
  withDefaults f ce vs ps
      | any null tss  = fail "cannot resolve ambiguity"
      | otherwise     = return (f vps (map head tss))
        where vps = ambiguities ce vs ps
              tss = map (candidates ce) vps
</pre>

<p>
The <tt>withDefaults</tt> function takes care of picking suitable
defaults, and of checking whether there are any ambiguities
that cannot be eliminated.  If defaulting succeeds, then the
list of predicates that can be eliminated is obtained by
concatenating the predicates in each <tt>Ambiguity</tt> pair:

<p>

<pre>
  defaultedPreds :: Monad m =&#62; ClassEnv -&#62; [Tyvar] -&#62; [Pred] -&#62; m [Pred]
  defaultedPreds  = withDefaults (\vps ts -&#62; concat (map snd vps))
</pre>

<p>
In a similar way, the defaulting substitution can be obtained
by zipping the list of variables together with the list of defaults:

<p>

<pre>
  defaultSubst   :: Monad m =&#62; ClassEnv -&#62; [Tyvar] -&#62; [Pred] -&#62; m Subst
  defaultSubst    = withDefaults (\vps ts -&#62; zip (map fst vps) ts)
</pre>

<p>
One might wonder why the defaulting substitution is useful to us here;
if the ambiguous variables don't appear anywhere in the assumptions or
in the inferred types, then applying this substitution to those components
would have no effect.  In fact, we will only need <tt>defaultSubst</tt> at
the top-level, when type inference for an entire module is complete
[<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>,Section 4.5.5, Rule 2].
In this case, it is possible that Haskell's infamous `monomorphism
restriction' (see Section&nbsp;<a href="#sec-impbind">11.6.2</a>) may prevent generalization
over some type variables.  But Haskell does not allow the types of
top-level functions to contain unbound type variables.  Instead, any
remaining variables are considered ambiguous, even if they appear in
inferred types; the substitution is needed to ensure that
they are bound correctly.

<p>
     <h3><a name="tth_sEc11.6">
11.6</a>&nbsp;&nbsp;Binding Groups</h3>
Our last remaining technical challenge is to
describe typechecking for binding groups.  This area is neglected
in most theoretical treatments of type inference, often
being regarded as a simple exercise in extending basic ideas.
In Haskell, at least, nothing could be further from the truth!
With interactions between overloading, polymorphic recursion, and
the mixing of both explicitly and implicitly typed bindings, this
is the most complex, and most subtle component of type inference.
We will start by describing the treatment of explicitly typed
bindings and implicitly typed bindings as separate cases, and
then show how these can be combined.

<p>
      <h4><a name="tth_sEc11.6.1">
11.6.1</a>&nbsp;&nbsp;Explicitly Typed Bindings</h4>
The simplest case is for explicitly typed bindings, each
of which is described by the name of the function that is
being defined, the declared type scheme, and the list of
alternatives in its definition:

<p>

<pre>
  type Expl = (Id, Scheme, [Alt])
</pre>

<p>
Haskell requires that each <tt>Alt</tt> in the definition of
a given identifier has the same number of left-hand side
arguments, but we do not need to enforce that here.

<p>
Type inference for an explicitly typed binding is
fairly easy; we need only check that the declared type
is valid, and do not need to infer a type from first
principles.  To support the use of polymorphic recursion
[<a href="#Henglein:polyrec" name="CITEHenglein:polyrec"> Henglein, 1993</a>,<a href="#Kfoury:polyrec" name="CITEKfoury:polyrec"> Kfoury <em>et&nbsp;al.</em> , 1993</a>], we will assume that
the declared typing for <tt>i</tt> is already included in the
assumptions when we call the following function:

<p>

<pre>
  tiExpl :: ClassEnv -&#62; [Assump] -&#62; Expl -&#62; TI [Pred]
  tiExpl ce as (i, sc, alts)
          = do (qs :=&#62; t) &lt;- freshInst sc
               ps         &lt;- tiAlts ce as alts t
               s          &lt;- getSubst
               let qs'     = apply s qs
                   t'      = apply s t
                   fs      = tv (apply s as)
                   gs      = tv t' \\ fs
                   sc'     = quantify gs (qs':=&#62;t')
                   ps'     = filter (not . entail ce qs') (apply s ps)
               (ds,rs)    &lt;- split ce fs gs ps'
               if sc /= sc' then
                   fail "signature too general"
                 else if not (null rs) then
                   fail "context too weak"
                 else
                   return ds
</pre>

<p>
This code begins by instantiating the declared type scheme
<tt>sc</tt> and checking each alternative against the resulting
type <tt>t</tt>.  When all of the alternatives have been processed,
the inferred type for <tt>i</tt> is <tt>qs' :=&#62; t'</tt>.  If the type
declaration is accurate, then this should be the same, up to
renaming of generic variables, as the original type <tt>qs:=&#62;t</tt>.
If the type signature is too general, then the calculation of
<tt>sc'</tt> will result in a type scheme that is more specific
than <tt>sc</tt> and an error will be reported.

<p>
In the meantime, we must discharge any predicates
that were generated while checking the list of alternatives.
Predicates that are entailed by the context <tt>qs'</tt> can be
eliminated without further ado.  Any remaining predicates are
collected in <tt>ps'</tt> and passed as arguments to <tt>split</tt>
along with the appropriate sets of fixed and generic variables.
If there are any retained predicates after context reduction,
then an error is reported, indicating that the declared
context is too weak.

<p>
      <h4><a name="tth_sEc11.6.2">
11.6.2</a>&nbsp;&nbsp;Implicitly Typed Bindings</h4><a name="sec-impbind">
</a>
Two complications occur when we deal with implicitly typed
bindings.  The first is that we must deal with groups of
mutually recursive bindings as a single unit rather than
inferring types for each binding one at a time.  The second is
Haskell's monomorphism restriction, which restricts the use of
overloading in certain cases.

<p>
A single implicitly typed binding is described by a pair
containing the name of the variable and a list of alternatives:

<p>

<pre>
  type Impl   = (Id, [Alt])
</pre>

<p>
The monomorphism restriction is invoked when one or more of the
entries in a list of implicitly typed bindings is simple, meaning
that it has an alternative with no left-hand side patterns.
The following function provides a way to test for this:

<p>

<pre>
  restricted   :: [Impl] -&#62; Bool
  restricted bs = any simple bs
   where simple (i,alts) = any (null . fst) alts
</pre>

<p>
Type inference for groups of mutually recursive, implicitly
typed bindings is described by the following function:

<p>

<pre>
  tiImpls         :: Infer [Impl] [Assump]
  tiImpls ce as bs = do ts &lt;- mapM (\_ -&#62; newTVar Star) bs
                        let is    = map fst bs
                            scs   = map toScheme ts
                            as'   = zipWith (:&#62;:) is scs ++ as
                            altss = map snd bs
                        pss &lt;- sequence (zipWith (tiAlts ce as') altss ts)
                        s   &lt;- getSubst
                        let ps'     = apply s (concat pss)
                            ts'     = apply s ts
                            fs      = tv (apply s as)
                            vss     = map tv ts'
                            gs      = foldr1 union vss \\ fs
                        (ds,rs) &lt;- split ce fs (foldr1 intersect vss) ps'
                        if restricted bs then
                            let gs'  = gs \\ tv rs
                                scs' = map (quantify gs' . ([]:=&#62;)) ts'
                            in return (ds++rs, zipWith (:&#62;:) is scs')
                          else
                            let scs' = map (quantify gs . (rs:=&#62;)) ts'
                            in return (ds, zipWith (:&#62;:) is scs')
</pre>

<p>
In the first part of this process, we extend <tt>as</tt> with
assumptions binding each identifier defined in <tt>bs</tt>
to a new type variable, and use these to type check
each alternative in each binding.  This is necessary to
ensure that each variable is used with the same type at
every occurrence within the defining list of bindings.
(Lifting this restriction makes type inference undecidable
[<a href="#Henglein:polyrec" name="CITEHenglein:polyrec"> Henglein, 1993</a>,<a href="#Kfoury:polyrec" name="CITEKfoury:polyrec"> Kfoury <em>et&nbsp;al.</em> , 1993</a>].)  Next we
use <tt>split</tt> to break the inferred
predicates in <tt>ps'</tt> into a list of deferred predicates
<tt>ds</tt> and retained predicates <tt>rs</tt>.  The list <tt>gs</tt>
collects all the generic variables that appear in one or more
of the inferred types <tt>ts'</tt>, but not in the list <tt>fs</tt>
of fixed variables.  Note that a different list is passed to
<tt>split</tt>, including only variables that appear in <em>all</em>
of the inferred types.
This is important because all of those types will
eventually be qualified by the same set of predicates, and we
do not want any of the resulting type schemes to be ambiguous.
The final step begins with a test to see if the monomorphism
restriction should be applied, and then continues to calculate
an assumption containing the principal types for each of the
defined values.  For an unrestricted binding, this is simply
a matter of qualifying over the retained predicates in <tt>rs</tt>
and quantifying over the generic variables in <tt>gs</tt>.  If the
binding group is restricted, then we must defer the predicates
in <tt>rs</tt> as well as those in <tt>ds</tt>, and hence we can only
quantify over variables in <tt>gs</tt> that do not appear in <tt>rs</tt>.

<p>
      <h4><a name="tth_sEc11.6.3">
11.6.3</a>&nbsp;&nbsp;Combined Binding Groups</h4><a name="sec-bindgroup">
</a>
Haskell requires a process of <em>dependency analysis</em> to
break down complete sets of bindings-either at the top-level of
a program, or within a local definition-into the smallest
possible groups of mutually recursive definitions, and ordered
so that no group depends on the values defined in later groups.
This is necessary to obtain the most general types possible.
For example, consider the following fragment from a standard
prelude for Haskell:

<pre>
   foldr f a (x:xs) = f x (foldr f a xs)
   foldr f a []     = a
   and xs           = foldr (&amp;&amp;) True xs
</pre>
If these definitions were placed in the same binding group, then
we would not obtain the most general possible type for <tt>foldr</tt>;
all occurrences of a variable are required to have the same type
at each point within the defining binding group, which would lead
to the following type for <tt>foldr</tt>:

<pre>
   (Bool -&#62; Bool -&#62; Bool) -&#62; Bool -&#62; [Bool] -&#62; Bool
</pre>
To avoid this problem, we need only notice that the definition
of <tt>foldr</tt> does not depend in any way on <tt>&amp;&amp;</tt>, and hence
we can place the two functions in separate binding groups, inferring
first the most general type for <tt>foldr</tt>, and then the correct
type for <tt>and</tt>.

<p>
In the presence of explicitly typed bindings, we can 
refine the dependency analysis process a little further.
For example, consider the following pair of bindings:

<pre>
   f   :: Eq a =&#62; a -&#62; Bool
   f x  = (x==x) || g True
   g y  = (y&lt;=y) || f True
</pre>
Although these bindings are mutually recursive, we do not need to
infer types for <tt>f</tt> and <tt>g</tt> at the same time.  Instead,
we can use the declared type of <tt>f</tt> to infer a type:

<pre>
   g   :: Ord a =&#62; a -&#62; Bool
</pre>
and then use this to check the body of <tt>f</tt>, ensuring
that its declared type is correct.

<p>
Motivated by these observations, we will represent Haskell
binding groups using the following datatype:

<p>

<pre>
  type BindGroup  = ([Expl], [[Impl]])
</pre>

<p>
The first component in each such pair lists any explicitly typed
bindings in the group.  The second component provides an opportunity
to break down the list of any implicitly typed bindings into several
smaller lists, arranged in dependency order.  In other words, if
a binding group is represented by a pair <tt>(es,[is_1,...,is_n])</tt>,
then the implicitly typed bindings in each <tt>is_i</tt> should depend
only on the bindings in <tt>es, is_1, ..., is_i</tt>, and not on
any bindings in <tt>is_j</tt> when <tt>j&#62;i</tt>.  (Bindings in <tt>es</tt>
could depend on any of the bindings in the group, but will presumably
depend on at least those in <tt>is_n</tt>, or else the group would
not be minimal.  Note also that
if <tt>es</tt> is empty, then <tt>n</tt> must be <tt>1</tt>.)  In choosing
this representation, we have assumed that dependency analysis has
been carried out prior to type checking, and that the bindings in
each group have been organized into values of type <tt>BindGroup</tt>
as appropriate.  In particular, by separating out implicitly typed
bindings as much as possible, we can potentially increase the degree
of polymorphism in inferred types.  For a correct implementation of
the semantics specified in the Haskell report, a simpler but less
flexible approach is required: all implicitly typed bindings must
be placed in a single list, even if a more refined decomposition
would be possible.  In addition, if the group is restricted, then
we must also ensure that none of the explicitly typed bindings
in the same <tt>BindGroup</tt> have any predicates in their type, even
though this is not strictly necessary.
With hindsight, these are restrictions that we
might prefer to avoid in any future revision of Haskell.

<p>
A more serious concern is that the Haskell report does not
indicate clearly whether the previous example defining
<tt>f</tt> and <tt>g</tt> should be valid.  At the time of
writing, some implementations accept it, while others do
not.  This is exactly the kind of problem that can occur
when there is no precise, formal specification!  Curiously,
however, the report does indicate that a modification of
the example to include an explicit type for <tt>g</tt> would
be illegal.  This is a consequence of a throw-away comment
specifying that all explicit type signatures in a binding
group must have the same context up to renaming of variables
[<a href="#Haskell98" name="CITEHaskell98"> Peyton Jones &amp; Hughes, 1999</a>,Section 4.5.2].
This is a syntactic
restriction that can easily be checked prior to type checking.
Our comments here, however, suggest that it is unnecessarily
restrictive.

<p>
In addition to the function bindings that we have seen already,
Haskell allows variables to be defined using pattern bindings
of the form <tt>pat = expr</tt>.  We do not need to deal directly
with such bindings because they are easily translated into
the simpler framework used in this paper.  For example, a
binding:

<pre>
   (x,y) = expr
</pre>
can be rewritten as:

<pre>
   nv = expr
   x  = fst nv
   y  = snd nv
</pre>
where <tt>nv</tt> is a new variable.  The precise definition
of the monomorphism restriction in Haskell makes specific
reference to pattern bindings, treating any binding group that
includes one as restricted.  So it may seem
that the definition of restricted binding groups in this paper
is not quite accurate.  However, if we use translations as
suggested here, then it turns out to be equivalent: even if the
programmer supplies explicit type signatures for <tt>x</tt>
and <tt>y</tt> in the original program, the translation
will still contain an implicitly typed binding
for the new variable <tt>nv</tt>.

<p>
Now, at last, we are ready to present the algorithm for type
inference of a complete binding group, as implemented by the
following function:

<p>

<pre>
  tiBindGroup :: Infer BindGroup [Assump]
  tiBindGroup ce as (es,iss) =
    do let as' = [ v:&#62;:sc | (v,sc,alts) &lt;- es ]
       (ps, as'') &lt;- tiSeq tiImpls ce (as'++as) iss
       qss        &lt;- mapM (tiExpl ce (as''++as'++as)) es
       return (ps++concat qss, as''++as')
</pre>

<p>
The structure of this definition is quite straightforward.
First we form a list of assumptions <tt>as'</tt> for each of the
explicitly typed bindings in the group.  Next, we use this
to check each group of implicitly typed bindings, extending
the assumption set further at each stage.  Finally, we return
to the explicitly typed bindings to verify that each of the
declared types is acceptable.  In dealing with the list of
implicitly typed binding groups, we use the following utility
function, which typechecks a list of binding groups and
accumulates assumptions as it runs through the list:

<p>

<pre>
  tiSeq                  :: Infer bg [Assump] -&#62; Infer [bg] [Assump]
  tiSeq ti ce as []       = return ([],[])
  tiSeq ti ce as (bs:bss) = do (ps,as')  &lt;- ti ce as bs
                               (qs,as'') &lt;- tiSeq ti ce (as'++as) bss
                               return (ps++qs, as''++as')
</pre>

<p>
      <h4><a name="tth_sEc11.6.4">
11.6.4</a>&nbsp;&nbsp;Top-level Binding Groups</h4><a name="sec-top-level">
</a>
At the top-level, a Haskell program can be thought of as
a list of binding groups:

<p>

<pre>
  type Program = [BindGroup]
</pre>

<p>
Even the definitions of member functions in class and instance
declarations can be included in this representation; they
can be translated into top-level, explicitly typed bindings.
The type inference process for a program takes a list of
assumptions giving the types of any primitives, and returns a
set of assumptions for any variables.

<p>

<pre>
  tiProgram :: ClassEnv -&#62; [Assump] -&#62; Program -&#62; [Assump]
  tiProgram ce as bgs = runTI $
                        do (ps, as') &lt;- tiSeq tiBindGroup ce as bgs
                           s         &lt;- getSubst
                           rs        &lt;- reduce ce (apply s ps)
                           s'        &lt;- defaultSubst ce [] rs
                           return (apply (s'@@s) as')
</pre>

<p>
This completes our presentation of the Haskell type system.

<p>
       <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Conclusions</h2>
We have presented a complete Haskell program that implements
a type checker for the Haskell language.  In the process,
we have clarified certain aspects of the current design,
as well as identifying some ambiguities in the existing,
informal specification.

<p>
The type checker has been developed, type-checked, and tested
using the ``Haskell 98 mode'' of Hugs 98 [<a href="#HugsManual" name="CITEHugsManual"> Jones &amp; Peterson, 1999</a>].
The full program includes many additional functions, not
shown in this paper, to ease the task of testing, debugging,
and displaying results.  We have also translated several
large Haskell programs-including the Standard Prelude,
the Maybe and List libraries, and the source code for the
type checker itself-into the representations described in
Section&nbsp;<a href="#sec-typeinf">11</a>, and successfully passed these through
the type checker.  As a result of these and other experiments we
have good evidence that the type checker is working as intended,
and in accordance with the expectations of Haskell programmers.

<p>
We believe that this typechecker can play a useful role, both
as a formal specification for the Haskell type system, and as a
testbed for experimenting with future extensions.

<p>

<h2>Acknowledgments</h2>
This paper has benefited from feedback from Johan Nordlander, Tom
Pledger, Lennart Augustsson, Stephen Eldridge, Tim Sheard, Andy
Gordon, and from an anonymous referee.
The research reported in this paper was supported, in part, by the
USAF Air Materiel Command, contract # F19628-96-C-0161, and by
the National Science Foundation grants CCR-9703218 and CCR-9974980.

<p>
<h2>References</h2>
<dl compact="compact">

<p>
<dt><a href="#CITEBlott" name="Blott">[ Blott, 1991]</a></dt><dd>
Blott, Stephen&nbsp;M. (1991).
 <em>An approach to overloading with polymorphism</em>.
 Ph.D. thesis, Department of Computing Science, University of Glasgow.

<p>
<dt><a href="#CITEDamasMilner" name="DamasMilner">[ Damas &amp; Milner, 1982]</a></dt><dd>
Damas, L., &amp; Milner, R. (1982).
 Principal type schemes for functional programs.
 <em>Pages  207-212 of:</em> <em>9th Annual ACM Symposium on
  Principles of Programming Languages</em>.

<p>
<dt><a href="#CITEGasterJones" name="GasterJones">[ Gaster &amp; Jones, 1996]</a></dt><dd>
Gaster, Benedict&nbsp;R., &amp; Jones, Mark&nbsp;P. (1996).
 <em>A polymorphic type system for extensible records and variants</em>.
 Technical Report NOTTCS-TR-96-3. Computer Science, University of
  Nottingham.

<p>
<dt><a href="#CITEHenglein:polyrec" name="Henglein:polyrec">[ Henglein, 1993]</a></dt><dd>
Henglein, Fritz. (1993).
 Type inference with polymorphic recursion.
 <em>ACM Transactions on Programming Languages and Systems</em>, <b>
  15</b>(2), 253-289.

<p>
<dt><a href="#CITEHindley" name="Hindley">[ Hindley, 1969]</a></dt><dd>
Hindley, R. (1969).
 The principal type-scheme of an object in combinatory logic.
 <em>Transactions of the American Mathematical Society</em>, <b>146</b>,
  29-60.

<p>
<dt><a href="#CITEQuality" name="Quality">[ Jones, 1992]</a></dt><dd>
Jones, Mark&nbsp;P. (1992).
 <em>Qualified types: Theory and practice</em>.
 Ph.D. thesis, Programming Research Group, Oxford University
  Computing Laboratory.
 Published by Cambridge University Press, November 1994.

<p>
<dt><a href="#CITEHugsManual" name="HugsManual">[ Jones &amp; Peterson, 1999]</a></dt><dd>
Jones, Mark&nbsp;P., &amp; Peterson, John&nbsp;C. (1999).
 <em>Hugs 98 User Manual</em>.
 Available from <tt>http://www.haskell.org/hugs/</tt>.

<p>
<dt><a href="#CITEKfoury:polyrec" name="Kfoury:polyrec">[ Kfoury <em>et&nbsp;al.</em> , 1993]</a></dt><dd>
Kfoury, A.J., Tiuryn, J., &amp; Urzyczyn, P. (1993).
 Type reconstruction in the presence of polymorphic recursion.
 <em>ACM Transactions on Programming Languages and Systems</em>, <b>
  15</b>(2), 290-311.

<p>
<dt><a href="#CITEMilner" name="Milner">[ Milner, 1978]</a></dt><dd>
Milner, R. (1978).
 A theory of type polymorphism in programming.
 <em>Journal of Computer and System Sciences</em>, <b>17</b>(3).

<p>
<dt><a href="#CITEHaskell98" name="Haskell98">[ Peyton Jones &amp; Hughes, 1999]</a></dt><dd>
Peyton Jones, Simon, &amp; Hughes, John (eds). (1999).
 <em>Report on the Programming Language Haskell 98, A
  Non-strict Purely Functional Language</em>.
 Available from <tt>http://www.haskell.org/definition/</tt>.

<p>
<dt><a href="#CITEmulti" name="multi">[ Peyton Jones <em>et&nbsp;al.</em> , 1997]</a></dt><dd>
Peyton Jones, Simon, Jones, Mark, &amp; Meijer, Erik. (1997).
 Type classes: Exploring the design space.
  <em>Proceedings of the second haskell workshop</em>.

<p>
<dt><a href="#CITERobinson" name="Robinson">[ Robinson, 1965]</a></dt><dd>
Robinson, J.A. (1965).
 A machine-oriented logic based on the resolution principle.
 <em>Journal of the Association for Computing Machinery</em>, <b>12</b>.

<p>
<dt><a href="#CITEWadler:Essence" name="Wadler:Essence">[ Wadler, 1992]</a></dt><dd>
Wadler, P. (1992).
 The essence of functional programming (invited talk).
 <em>Pages  1-14 of:</em> <em>Conference record of the Nineteenth
  annual ACM SIGPLAN-SIGACT symposium on Principles of Programming
  Languages</em>.

<p>
<dt><a href="#CITEWadlerBlott" name="WadlerBlott">[ Wadler &amp; Blott, 1989]</a></dt><dd>
Wadler, P., &amp; Blott, S. (1989).
 How to make <em>ad hoc</em> polymorphism less <em>ad hoc</em>.
 <em>Pages  60-76 of:</em> <em>Proceedings of 16th ACM Symposium on
  Principles of Programming Languages</em>.

<p>
</dl><hr><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>An earlier
version of this paper was presented at the Haskell workshop in Paris, France,
on October 1, 2000.  Both papers describe the same type system, but some
significant parts of this version have been rewritten, restructured, or
expanded to clarify the presentation.
<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>Throughout, we use `Haskell' as an
abbreviation for `Haskell 98'.
<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>The `maps to' symbol <tt>+-&#62;</tt> is written as <tt>+-&#62;</tt>
in the concrete syntax of Haskell.
<p>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>The symbol <tt>:=&#62;</tt>
(pronounced `then') is written as <tt>:=&#62;</tt> in the concrete syntax
of Haskell, and corresponds directly to the <tt> =&#62;</tt> symbol that
is used in instance declarations and in types.
<p>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>The same function appears in
the standard <tt>Maybe</tt> library, but with a less intuitive name:
<tt>isJust</tt>.
<br><br><hr><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.73.<br>On 23 Nov 2000, 08:00.</small>
</html>
